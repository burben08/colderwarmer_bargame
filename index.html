<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zurich Bar Hunt</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: #f5f5f5;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 15px;
        }

        .game-info {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            font-size: 14px;
        }

        .game-info span {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 12px;
            border-radius: 6px;
        }

        .search-container {
            display: flex;
            gap: 10px;
            max-width: 600px;
        }

        .search-input {
            flex: 1;
            padding: 12px 16px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            outline: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .search-btn {
            padding: 12px 24px;
            background: white;
            color: #667eea;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .search-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .search-btn:active {
            transform: translateY(0);
        }

        .search-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .reset-btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid white;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .reset-btn:hover {
            background: white;
            color: #667eea;
        }

        .message {
            margin-top: 10px;
            padding: 10px 16px;
            border-radius: 6px;
            font-size: 14px;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.success { background: rgba(255, 255, 255, 0.2); color: white; }
        .message.error { background: rgba(255, 255, 255, 0.2); color: #ffe0e0; }
        .message.win { background: #4CAF50; color: white; font-weight: 600; font-size: 16px; }
        .message.warmer { background: rgba(255, 100, 50, 0.3); color: white; font-weight: 600; }
        .message.colder { background: rgba(100, 150, 255, 0.3); color: white; font-weight: 600; }

        #map {
            flex: 1;
            width: 100%;
        }

        .leaflet-popup-content-wrapper { border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        .leaflet-popup-content { margin: 12px; font-size: 14px; }
        .bar-popup h3 { margin: 0 0 8px 0; color: #667eea; font-size: 16px; }
        .bar-popup p { margin: 4px 0; color: #666; }

        .visit-number {
            display: inline-block;
            background: #667eea;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            text-align: center;
            line-height: 24px;
            font-weight: 600;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üç∫ Zurich Bar Hunt Game</h1>
        <div class="game-info">
            <span>üéØ Target: <strong id="targetBar">???</strong></span>
            <span>üìç Visits: <strong id="visitCount">0</strong></span>
            <span>üìç Starting Point: <strong id="startingBar">Paradeplatz</strong></span>
        </div>
        <div class="search-container">
            <input type="text" id="barInput" class="search-input" placeholder="Guess the bar name..." autocomplete="off"/>
            <button id="searchBtn" class="search-btn">Try Bar</button>
            <button id="resetBtn" class="reset-btn">New Game</button>
        </div>
        <div id="message"></div>
    </div>
    <div id="map"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script>
        // Game bounds in Latitude/Longitude
        const GAME_BOUNDS = { south: 47.365, north: 47.391, west: 8.514, east: 8.55 };

        let gameState = {
            targetBar: null, targetLocation: null, visitedBars: [],
            visitCount: 0, gameWon: false,
            startingPoint: { name: 'Paradeplatz', lat: 47.3697, lng: 8.5392 }
        };
        
        const zurichBars = [
            'Zentralw√§scherei', 'Mars Bar', 'Gleis', 'Rio Bar',
            'Ol√© Ol√©', 'El Lokal', 'Ebrietas', 'Hafenkneipe',
            'Safari Bar', 'Kaufleuten', 'Moods', 'George',
            'Caf√© Odeon', 'ELISABURG', 'Old Crow', 'Brick', 'Bar am Wasser',
            'Tales Bar', 'Widder Bar', 'Bar A Dox', 'Bar Basso',
            'Jules Verne Bar', 'Kronenhalle Bar', 'Cinchona Bar', 'Clouds Bar', 'Bar Sacchi',
            'Barfussbar', 'KLE', 'Rosi', 'Lupo', 'Bar Le Philosophe', 'BIERlab', 'Bar Rossi',
            'Big Ben Pub', 'Le Cactus', 'Xenix', 'Spaghetti Factory', 'Kanzlei',
            'Volkshaus', 'Helvti', 'Les Halles', 'Raygrodski', 'Brick Cocktailbar',
            'Onyx Bar', 'Le Raymond Bar', 'Loft Five', 'Bar Otro', 'Campo', 'Brick', 'Cafe Z√§hringer'
        ];

        const map = L.map('map').setView([47.3769, 8.5417], 14);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors', maxZoom: 19
        }).addTo(map);

        const gameArea = L.rectangle(
            [[GAME_BOUNDS.south, GAME_BOUNDS.west], [GAME_BOUNDS.north, GAME_BOUNDS.east]],
            { color: '#667eea', weight: 2, fillOpacity: 0.1, dashArray: '5, 5' }
        ).addTo(map);
        gameArea.bindPopup('Game Area - Find bars within this zone!');

        let markers = [];
        let pathLine = null;
        let eliminationZones = [];

        // --- ICONS (Unchanged) ---
        const visitedIcon = (number, isWarmer) => L.divIcon({ html: `<div style="background: ${isWarmer ? '#FF6347' : '#4169E1'}; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: 600; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">${number}</div>`, className: '', iconSize: [32, 32], iconAnchor: [16, 16], popupAnchor: [0, -16] });
        const winIcon = L.divIcon({ html: '<div style="background: #4CAF50; color: white; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px; border: 3px solid white; box-shadow: 0 2px 12px rgba(0,0,0,0.4); animation: pulse 1s infinite;">üéâ</div><style>@keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); }}</style>', className: '', iconSize: [40, 40], iconAnchor: [20, 20], popupAnchor: [0, -20] });
        const startIcon = L.divIcon({ html: '<div style="background: #FFA500; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 18px; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">üèÅ</div>', className: '', iconSize: [32, 32], iconAnchor: [16, 16], popupAnchor: [0, -16] });
        
        // --- NEW INTEGRATED ALGORITHM ---

        /**
         * Calculates the vertices of a rectangular slice. This is the robust clipping algorithm.
         * It operates on a standard Cartesian plane {x, y}.
         */
        function getRectangleSlice(rect, pointA, pointB) {
            const dx = pointB.x - pointA.x;
            const dy = pointB.y - pointA.y;

            if (Math.abs(dx) < 1e-9 && Math.abs(dy) < 1e-9) {
                return [ { x: rect.x, y: rect.y }, { x: rect.x + rect.width, y: rect.y }, { x: rect.x + rect.width, y: rect.y + rect.height }, { x: rect.x, y: rect.y + rect.height }];
            }

            const midPoint = { x: (pointA.x + pointB.x) / 2, y: (pointA.y + pointB.y) / 2 };
            const line = { a: dx, b: dy, c: -dx * midPoint.x - dy * midPoint.y };
            const sideOfA = line.a * pointA.x + line.b * pointA.y + line.c;
            const isInside = (p) => (line.a * p.x + line.b * p.y + line.c) * sideOfA >= 0;

            const subjectPolygon = [ { x: rect.x, y: rect.y }, { x: rect.x + rect.width, y: rect.y }, { x: rect.x + rect.width, y: rect.y + rect.height }, { x: rect.x, y: rect.y + rect.height } ];

            const outputPolygon = [];
            let S = subjectPolygon[subjectPolygon.length - 1];
            for (const E of subjectPolygon) {
                const sIsInside = isInside(S);
                const eIsInside = isInside(E);
                if (eIsInside) {
                    if (!sIsInside) outputPolygon.push(getIntersection(S, E, line));
                    outputPolygon.push(E);
                } else if (sIsInside) {
                    outputPolygon.push(getIntersection(S, E, line));
                }
                S = E;
            }
            return outputPolygon;
        }
        
        /**
         * Helper function to find the intersection of a line segment and an infinite line.
         */
        function getIntersection(p1, p2, line) {
            const { a, b, c } = line;
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const denominator = a * dx + b * dy;
            if (Math.abs(denominator) < 1e-9) return p1;
            const t = -(a * p1.x + b * p1.y + c) / denominator;
            return { x: p1.x + t * dx, y: p1.y + t * dy };
        }
        
        /**
         * NEW: Creates the shaded elimination zone using the clipping algorithm.
         * This function acts as a bridge between Leaflet's lat/lng and the algorithm's x/y system.
         */
        function createEliminationZone(prevBar, currentBar, isWarmer) {
            // 1. Define the rectangle for the algorithm (lng -> x, lat -> y)
            const rect = {
                x: GAME_BOUNDS.west,
                y: GAME_BOUNDS.south,
                width: GAME_BOUNDS.east - GAME_BOUNDS.west,
                height: GAME_BOUNDS.north - GAME_BOUNDS.south
            };
            
            // 2. Determine which point is on the side to be eliminated.
            const pointToEliminate = isWarmer ? prevBar : currentBar;
            const pointToKeep = isWarmer ? currentBar : prevBar;

            // 3. Convert lat/lng to the algorithm's x/y coordinate system.
            const pointA_xy = { x: pointToEliminate.lng, y: pointToEliminate.lat };
            const pointB_xy = { x: pointToKeep.lng, y: pointToKeep.lat };

            // 4. Call the algorithm to get the vertices of the elimination polygon.
            const polygonVertices = getRectangleSlice(rect, pointA_xy, pointB_xy);
            
            if (polygonVertices.length < 3) return null;

            // 5. Convert the resulting x/y vertices back to [lat, lng] for Leaflet.
            const leafletCoords = polygonVertices.map(p => [p.y, p.x]); // Leaflet uses [lat, lng]

            const zone = L.polygon(leafletCoords, {
                color: '#dc2626', // red-600
                weight: 1,
                fillColor: '#ef4444', // red-500
                fillOpacity: 0.1
            }).addTo(map);
            
            eliminationZones.push(zone);
        }

        // --- GAME LOGIC (Mostly Unchanged) ---

        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p1.lat - p2.lat, 2) + Math.pow(p1.lng - p2.lng, 2));
        }

        async function geocodeLocation(query) {
            const url = `https://photon.komoot.io/api/?q=${encodeURIComponent(query)}&lon=8.5417&lat=47.3769&limit=5`;
            const response = await fetch(url);
            if (!response.ok) throw new Error('Network response was not ok');
            const data = await response.json();
            if (!data.features || data.features.length === 0) throw new Error('Location not found');
            
            let bestResult = null;
            for (const feature of data.features) {
                const coords = feature.geometry.coordinates;
                const lng = coords[0];
                const lat = coords[1];
                
                if (lat >= GAME_BOUNDS.south && lat <= GAME_BOUNDS.north && lng >= GAME_BOUNDS.west && lng <= GAME_BOUNDS.east) {
                    if (!bestResult) bestResult = { lat, lng }; // Take the first valid result
                }
            }
            if (!bestResult) throw new Error('Location not in game area');
            return bestResult;
        }

        function showMessage(text, type) {
            const msgDiv = document.getElementById('message');
            msgDiv.textContent = text;
            msgDiv.className = `message ${type}`;
            if (type !== 'win') {
                setTimeout(() => { msgDiv.textContent = ''; msgDiv.className = ''; }, 3000);
            }
        }

        function updatePath() {
            if (pathLine) map.removeLayer(pathLine);
            if (gameState.visitedBars.length > 0) {
                const points = [ [gameState.startingPoint.lat, gameState.startingPoint.lng], ...gameState.visitedBars.map(bar => [bar.lat, bar.lng]) ];
                pathLine = L.polyline(points, { color: '#667eea', weight: 3, opacity: 0.7, dashArray: '10, 10' }).addTo(map);
            }
        }

        async function initGame() {
            markers.forEach(marker => map.removeLayer(marker));
            markers = [];
            if (pathLine) map.removeLayer(pathLine);
            eliminationZones.forEach(zone => map.removeLayer(zone));
            eliminationZones = [];

            let targetLoc;
            let targetBarName;

            while (!targetLoc) {
                targetBarName = zurichBars[Math.floor(Math.random() * zurichBars.length)];
                try {
                    targetLoc = await geocodeLocation(targetBarName);
                } catch (err) {
                    console.warn(`Failed to find "${targetBarName}": ${err.message}`);
                }
            }

            console.log(targetBarName);

            gameState = {
                targetBar: targetBarName, targetLocation: targetLoc,
                visitedBars: [], visitCount: 0, gameWon: false,
                startingPoint: { name: 'Paradeplatz', lat: 47.3697, lng: 8.5392 }
            };

            const startMarker = L.marker([gameState.startingPoint.lat, gameState.startingPoint.lng], { icon: startIcon }).addTo(map);
            startMarker.bindPopup(`<div class="bar-popup"><h3>üèÅ Starting Point</h3><p>${gameState.startingPoint.name}</p><p>Find the hidden bar from here!</p></div>`);
            markers.push(startMarker);

            document.getElementById('targetBar').textContent = '???';
            document.getElementById('visitCount').textContent = '0';
            document.getElementById('barInput').disabled = false;
            document.getElementById('searchBtn').disabled = false;
            showMessage('New game started! Find the hidden bar.', 'success');
            map.setView([47.3769, 8.5417], 14);
        }

        async function tryBar() {
            if (gameState.gameWon) return;
            const input = document.getElementById('barInput');
            const btn = document.getElementById('searchBtn');
            const query = input.value.trim();
            if (!query) { showMessage('Please enter a bar name', 'error'); return; }

            btn.disabled = true;
            btn.textContent = 'Searching...';

            try {
                const location = await geocodeLocation(query);
                const prevLocation = gameState.visitedBars.length > 0 ? gameState.visitedBars[gameState.visitedBars.length - 1] : gameState.startingPoint;
                
                const currentDist = distance(location, gameState.targetLocation);
                const prevDist = distance(prevLocation, gameState.targetLocation);
                const isWarmer = currentDist < prevDist;
                
                gameState.visitCount++;
                gameState.visitedBars.push({ name: query, ...location });

                const isWin = query.toLowerCase().includes(gameState.targetBar.toLowerCase()) || gameState.targetBar.toLowerCase().includes(query.toLowerCase());
                const icon = isWin ? winIcon : visitedIcon(gameState.visitCount, isWarmer);
                
                const marker = L.marker([location.lat, location.lng], { icon }).addTo(map)
                    .bindPopup(`<div class="bar-popup"><h3>${isWin ? 'üéâ ' : (isWarmer ? 'üî• ' : '‚ùÑÔ∏è ')}${query}</h3><p><span class="visit-number">${gameState.visitCount}</span> Visit #${gameState.visitCount}</p>${!isWin ? `<p style="font-weight: 600; color: ${isWarmer ? '#FF6347' : '#4169E1'}">${isWarmer ? 'üî• Warmer!' : '‚ùÑÔ∏è Colder!'}</p>` : ''}${isWin ? '<p style="color: #4CAF50; font-weight: 600;">YOU FOUND IT!</p>' : ''}</div>`)
                    .openPopup();
                markers.push(marker);
                
                createEliminationZone(prevLocation, location, isWarmer);
                
                updatePath();
                map.flyTo([location.lat, location.lng], 15, { duration: 1 });

                document.getElementById('visitCount').textContent = gameState.visitCount;

                if (isWin) {
                    gameState.gameWon = true;
                    document.getElementById('targetBar').textContent = gameState.targetBar;
                    showMessage(`üéâ Congratulations! You found ${gameState.targetBar} in ${gameState.visitCount} tries!`, 'win');
                    input.disabled = true;
                    btn.disabled = true;
                } else {
                    showMessage(isWarmer ? 'üî• Getting warmer!' : '‚ùÑÔ∏è Getting colder!', isWarmer ? 'warmer' : 'colder');
                }
                input.value = '';
            } catch (error) {
                showMessage(`Could not find "${query}" in the game area.`, 'error');
            } finally {
                if (!gameState.gameWon) {
                    btn.disabled = false;
                    btn.textContent = 'Try Bar';
                }
            }
        }

        document.getElementById('searchBtn').addEventListener('click', tryBar);
        document.getElementById('barInput').addEventListener('keypress', (e) => { if (e.key === 'Enter') tryBar(); });
        document.getElementById('resetBtn').addEventListener('click', initGame);

        initGame();
    </script>
</body>
</html>
