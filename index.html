<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bar Hunt Game</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100vh; overflow: hidden; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; display: flex; flex-direction: column; background: #f5f5f5; }
        .hidden { display: none !important; }

        /* --- Initial Setup Screen --- */
        #initialSetupScreen {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        .initial-setup-card {
            background: white;
            padding: 50px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 90%;
        }
        .initial-setup-card h1 { 
            font-size: 32px; 
            text-align: center; 
            margin-bottom: 40px; 
            color: #333;
        }
        .setup-group { 
            display: flex; 
            flex-direction: column; 
            margin-bottom: 25px;
        }
        .setup-group label { 
            margin-bottom: 10px; 
            font-weight: 600; 
            color: #555; 
            font-size: 16px;
        }
        .setup-group input { 
            padding: 15px; 
            border: 2px solid #ddd; 
            border-radius: 10px; 
            font-size: 16px; 
            outline: none;
            transition: border 0.2s;
        }
        .setup-group input:focus {
            border-color: #667eea;
        }
        .size-options {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        .size-btn {
            padding: 15px;
            border: 2px solid #ddd;
            background: white;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            color: #666;
        }
        .size-btn:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }
        .size-btn.selected {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }
        #continueBtn {
            width: 100%;
            padding: 18px;
            margin-top: 30px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        #continueBtn:hover { 
            background: #5a6edc; 
            transform: translateY(-2px);
        }
        #continueBtn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        #initialSetupError { 
            color: #e53e3e; 
            text-align: center; 
            margin-top: 15px; 
            min-height: 20px; 
            font-size: 14px;
        }

        /* --- Boundary Adjustment Screen --- */
        #boundarySetupScreen {
            display: grid;
            grid-template-columns: 350px 1fr;
            height: 100%;
            background: #f0f2f5;
        }
        .boundary-controls {
            background: white;
            padding: 30px;
            box-shadow: 5px 0 15px rgba(0,0,0,0.1);
            z-index: 10;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        .boundary-controls h2 { 
            font-size: 24px; 
            margin-bottom: 10px; 
            color: #333; 
        }
        .boundary-controls p {
            color: #666;
            margin-bottom: 25px;
            font-size: 14px;
        }
        .boundary-adjust {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 25px;
        }
        .boundary-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .boundary-row label {
            flex: 1;
            font-weight: 500;
            color: #555;
        }
        .adjust-btn {
            width: 40px;
            height: 40px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 8px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .adjust-btn:hover {
            background: #667eea;
            color: white;
        }
        .boundary-value {
            min-width: 80px;
            text-align: center;
            font-family: monospace;
            font-size: 14px;
            color: #333;
        }
        #startGameBtn {
            width: 100%;
            padding: 15px;
            margin-top: auto;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }
        #startGameBtn:hover { background: #5a6edc; }
        #startGameBtn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        #boundaryError { 
            color: #e53e3e; 
            text-align: center; 
            margin-top: 15px; 
            min-height: 20px; 
            font-size: 14px;
        }
        #boundaryMap { 
            height: 100%; 
            width: 100%; 
            background: #e9e9e9; 
        }
        #backBtn {
            width: 100%;
            padding: 12px;
            margin-bottom: 20px;
            background: #e0e0e0;
            color: #333;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }
        #backBtn:hover { background: #d0d0d0; }

        /* --- Game Screen --- */
        #gameScreen { height: 100%; display: flex; flex-direction: column; }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 1000; position: relative; }
        .header h1 { font-size: 24px; margin-bottom: 15px; }
        .game-info { display: flex; gap: 20px; margin-bottom: 15px; font-size: 14px; }
        .game-info span { background: rgba(255, 255, 255, 0.2); padding: 8px 12px; border-radius: 6px; }
        .search-container { display: flex; gap: 10px; max-width: 600px; align-items: center; }
        .search-input { flex: 1; padding: 12px 16px; border: none; border-radius: 8px; font-size: 16px; outline: none; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .search-input:disabled { background: #f0f0f0; }
        .btn { padding: 12px 24px; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.2s; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        .btn:active { transform: translateY(0); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }
        .btn-primary { background: white; color: #667eea; }
        .btn-confirm { background: #28a745; color: white; }
        .btn-cancel { background: #dc3545; color: white; }
        #resetBtn { position: absolute; top: 20px; right: 20px; background: none; border: none; cursor: pointer; }
        #resetBtn svg { width: 32px; height: 32px; fill: white; transition: transform 0.3s; }
        #resetBtn:hover svg { transform: rotate(180deg); }
        .message { margin-top: 10px; padding: 10px 16px; border-radius: 6px; font-size: 14px; animation: slideIn 0.3s ease-out; }
        @keyframes slideIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
        .message.success { background: rgba(255, 255, 255, 0.2); color: white; }
        .message.error { background: rgba(255, 255, 255, 0.2); color: #ffe0e0; }
        .message.win { background: #4CAF50; color: white; font-weight: 600; font-size: 16px; }
        .message.warmer { background: rgba(255, 100, 50, 0.3); color: white; font-weight: 600; }
        .message.colder { background: rgba(100, 150, 255, 0.3); color: white; font-weight: 600; }
        #map { flex: 1; width: 100%; }
        .leaflet-popup-content-wrapper { border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        .leaflet-popup-content { margin: 12px; font-size: 14px; }
        .bar-popup h3 { margin: 0 0 8px 0; color: #667eea; font-size: 16px; }
        .bar-popup p { margin: 4px 0; color: #666; }
        .visit-number { display: inline-block; background: #667eea; color: white; width: 24px; height: 24px; border-radius: 50%; text-align: center; line-height: 24px; font-weight: 600; font-size: 12px; }

        /* --- Mobile Responsiveness --- */
        @media (max-width: 768px) {
            .initial-setup-card {
                padding: 30px 20px;
            }
            .size-options {
                grid-template-columns: repeat(2, 1fr);
            }
            #boundarySetupScreen {
                display: flex;
                flex-direction: column;
                height: 100vh;
            }
            .boundary-controls {
                flex-shrink: 0;
                overflow-y: auto;
                padding: 20px;
                box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            }
            #boundaryMap {
                flex-grow: 1;
                min-height: 300px;
            }
            .header {
                padding: 15px;
            }
            .header h1 {
                font-size: 20px;
            }
            .game-info {
                flex-wrap: wrap;
                gap: 8px;
                margin-bottom: 10px;
            }
            .search-container {
                flex-wrap: wrap;
            }
            .search-input {
                flex-basis: 100%;
            }
            .search-container .btn {
                flex-grow: 1;
                padding: 12px 10px;
            }
            #resetBtn {
                top: 15px;
                right: 15px;
            }
            #resetBtn svg {
                width: 28px;
                height: 28px;
            }
        }
    </style>
</head>
<body>

    <div id="initialSetupScreen">
        <div class="initial-setup-card">
            <h1>🍺 New Bar Hunt</h1>
            <div class="setup-group">
                <label for="startLocationInput">Starting Location</label>
                <input type="text" id="startLocationInput" value="Paradeplatz, Zurich" placeholder="Enter a location...">
            </div>
            <div class="setup-group">
                <label>Game Boundary Size</label>
                <div class="size-options">
                    <button class="size-btn" data-size="S">S</button>
                    <button class="size-btn selected" data-size="M">M</button>
                    <button class="size-btn" data-size="L">L</button>
                    <button class="size-btn" data-size="XL">XL</button>
                </div>
            </div>
            <div id="initialSetupError"></div>
            <button id="continueBtn">Continue to Map</button>
        </div>
    </div>

    <div id="boundarySetupScreen" class="hidden">
        <div class="boundary-controls">
            <button id="backBtn">← Back</button>
            <h2>Adjust Game Area</h2>
            <p>Fine-tune the boundaries of the game area.</p>
            <div class="boundary-adjust">
                <div class="boundary-row">
                    <label>North</label>
                    <button class="adjust-btn" data-direction="north" data-amount="-0.001">−</button>
                    <span class="boundary-value" id="northValue">47.390</span>
                    <button class="adjust-btn" data-direction="north" data-amount="0.001">+</button>
                </div>
                <div class="boundary-row">
                    <label>South</label>
                    <button class="adjust-btn" data-direction="south" data-amount="0.001">−</button>
                    <span class="boundary-value" id="southValue">47.365</span>
                    <button class="adjust-btn" data-direction="south" data-amount="-0.001">+</button>
                </div>
                <div class="boundary-row">
                    <label>East</label>
                    <button class="adjust-btn" data-direction="east" data-amount="-0.001">−</button>
                    <span class="boundary-value" id="eastValue">8.560</span>
                    <button class="adjust-btn" data-direction="east" data-amount="0.001">+</button>
                </div>
                <div class="boundary-row">
                    <label>West</label>
                    <button class="adjust-btn" data-direction="west" data-amount="0.001">−</button>
                    <span class="boundary-value" id="westValue">8.520</span>
                    <button class="adjust-btn" data-direction="west" data-amount="-0.001">+</button>
                </div>
            </div>
            <div id="boundaryError"></div>
            <button id="startGameBtn">Start Game</button>
        </div>
        <div id="boundaryMap"></div>
    </div>

    <div id="gameScreen" class="hidden">
        <div class="header">
            <button id="resetBtn" title="New Game">
                <svg viewBox="0 0 24 24"><path d="M17.65,6.35C16.2,4.9,14.21,4,12,4A8,8,0,0,0,4,12A8,8,0,0,0,12,20C15.73,20,18.84,17.45,19.73,14H17.65C16.83,16.33,14.61,18,12,18A6,6,0,0,1,6,12A6,6,0,0,1,12,6C13.55,6,14.93,6.6,15.96,7.65L13,10.61H20V3.61L17.65,6.35Z"></path></svg>
            </button>
            <h1>🍺 Bar Hunt Game</h1>
            <div class="game-info">
                <span>🎯 Target: <strong id="targetBar">???</strong></span>
                <span>🏃 Visits: <strong id="visitCount">0</strong></span>
                <span>🏁 Starting Point: <strong id="startingBar">Paradeplatz</strong></span>
            </div>
            <div class="search-container">
                <input type="text" id="barInput" class="search-input" placeholder="Enter a bar name..." autocomplete="off"/>
                <button id="previewBtn" class="btn btn-primary">Preview</button>
                <button id="confirmBtn" class="btn btn-confirm hidden">Confirm Guess</button>
                <button id="cancelBtn" class="btn btn-cancel hidden">Cancel</button>
            </div>
            <div id="message"></div>
        </div>
        <div id="map"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script>
        // --- DOM ELEMENTS ---
        const initialSetupScreen = document.getElementById('initialSetupScreen');
        const boundarySetupScreen = document.getElementById('boundarySetupScreen');
        const gameScreen = document.getElementById('gameScreen');
        const continueBtn = document.getElementById('continueBtn');
        const startGameBtn = document.getElementById('startGameBtn');
        const backBtn = document.getElementById('backBtn');
        const barInput = document.getElementById('barInput');
        const previewBtn = document.getElementById('previewBtn');
        const confirmBtn = document.getElementById('confirmBtn');
        const cancelBtn = document.getElementById('cancelBtn');
        const resetBtn = document.getElementById('resetBtn');

        // --- SIZE PRESETS ---
        const SIZE_PRESETS = {
            'S': 1,
            'M': 2,
            'L': 10,
            'XL': 100
        };
        let selectedSize = 'M';

        // --- GAME STATE & VARS ---
        let GAME_BOUNDS = { south: 47.365, north: 47.39, west: 8.52, east: 8.56 };
        let centerLocation = { lat: 47.3769, lng: 8.5417 };
        let gameState = {
            targetBar: null, targetLocation: null, visitedBars: [],
            visitCount: 0, gameWon: false,
            startingPoint: { name: 'Paradeplatz', lat: 47.3697, lng: 8.5392 }
        };
        let allBarsInArea = []; // FIX 1: To store bars and prevent re-fetching
        let previewedLocation = null;
        let map = null;
        let boundaryMap = null;
        let boundaryRectangle = null;
        let gameArea = null;
        let markers = [];
        let pathLine = null;
        let eliminationZones = [];
        let previewLine = null;
        let previewMarker = null;

        // --- ICONS ---
        const visitedIcon = (number, isWarmer) => L.divIcon({ html: `<div style="background: ${isWarmer ? '#FF6347' : '#4169E1'}; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: 600; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">${number}</div>`, className: '', iconSize: [32, 32], iconAnchor: [16, 16], popupAnchor: [0, -16] });
        const winIcon = L.divIcon({ html: '<div style="background: #4CAF50; color: white; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px; border: 3px solid white; box-shadow: 0 2px 12px rgba(0,0,0,0.4); animation: pulse 1s infinite;">🎉</div><style>@keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); }}</style>', className: '', iconSize: [40, 40], iconAnchor: [20, 20], popupAnchor: [0, -20] });
        const startIcon = L.divIcon({ html: '<div style="background: #FFA500; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 18px; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">🏁</div>', className: '', iconSize: [32, 32], iconAnchor: [16, 16], popupAnchor: [0, -16] });
        const previewIcon = L.divIcon({ html: '<div style="background: #f97316; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 18px; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">?</div>', className: '', iconSize: [32, 32], iconAnchor: [16, 16] });

        // --- ALGORITHMS ---
        function getBisectorLinePoints(p1_xy, p2_xy) {
            const rect = { x: GAME_BOUNDS.west, y: GAME_BOUNDS.south, width: GAME_BOUNDS.east - GAME_BOUNDS.west, height: GAME_BOUNDS.north - GAME_BOUNDS.south };
            const dx = p2_xy.x - p1_xy.x;
            const dy = p2_xy.y - p1_xy.y;
            if (Math.abs(dx) < 1e-9 && Math.abs(dy) < 1e-9) return [];
            const midPoint = { x: (p1_xy.x + p2_xy.x) / 2, y: (p1_xy.y + p2_xy.y) / 2 };
            const a = dx; const b = dy; const c = -dx * midPoint.x - dy * midPoint.y;
            const intersections = [];
            if (Math.abs(a) > 1e-9) { const x_top = (-c - b * (rect.y + rect.height)) / a; if (x_top >= rect.x && x_top <= rect.x + rect.width) intersections.push({ y: rect.y + rect.height, x: x_top }); }
            if (Math.abs(a) > 1e-9) { const x_bottom = (-c - b * rect.y) / a; if (x_bottom >= rect.x && x_bottom <= rect.x + rect.width) intersections.push({ y: rect.y, x: x_bottom }); }
            if (Math.abs(b) > 1e-9) { const y_left = (-c - a * rect.x) / b; if (y_left >= rect.y && y_left <= rect.y + rect.height) intersections.push({ y: y_left, x: rect.x }); }
            if (Math.abs(b) > 1e-9) { const y_right = (-c - a * (rect.x + rect.width)) / b; if (y_right >= rect.y && y_right <= rect.y + rect.height) intersections.push({ y: y_right, x: rect.x + rect.width }); }
            const uniquePoints = []; const seen = new Set();
            for (const p of intersections) { const key = `${p.x.toFixed(7)},${p.y.toFixed(7)}`; if (!seen.has(key)) { uniquePoints.push(p); seen.add(key); } }
            return uniquePoints.length >= 2 ? [ [uniquePoints[0].y, uniquePoints[0].x], [uniquePoints[1].y, uniquePoints[1].x] ] : [];
        }
        
        function getRectangleSlice(rect, pointA, pointB) {
            const dx = pointB.x - pointA.x; const dy = pointB.y - pointA.y;
            if (Math.abs(dx) < 1e-9 && Math.abs(dy) < 1e-9) { return [ { x: rect.x, y: rect.y }, { x: rect.x + rect.width, y: rect.y }, { x: rect.x + rect.width, y: rect.y + rect.height }, { x: rect.x, y: rect.y + rect.height }]; }
            const midPoint = { x: (pointA.x + pointB.x) / 2, y: (pointA.y + pointB.y) / 2 };
            const line = { a: dx, b: dy, c: -dx * midPoint.x - dy * midPoint.y };
            const sideOfA = line.a * pointA.x + line.b * pointA.y + line.c;
            const isInside = (p) => (line.a * p.x + line.b * p.y + line.c) * sideOfA >= 0;
            const subjectPolygon = [ { x: rect.x, y: rect.y }, { x: rect.x + rect.width, y: rect.y }, { x: rect.x + rect.width, y: rect.y + rect.height }, { x: rect.x, y: rect.y + rect.height } ];
            const outputPolygon = []; let S = subjectPolygon[subjectPolygon.length - 1];
            for (const E of subjectPolygon) {
                const sIsInside = isInside(S); const eIsInside = isInside(E);
                if (eIsInside) { if (!sIsInside) outputPolygon.push(getIntersection(S, E, line)); outputPolygon.push(E); } else if (sIsInside) { outputPolygon.push(getIntersection(S, E, line)); }
                S = E;
            } return outputPolygon;
        }

        function getIntersection(p1, p2, line) {
            const { a, b, c } = line; const dx = p2.x - p1.x; const dy = p2.y - p1.y;
            const denominator = a * dx + b * dy; if (Math.abs(denominator) < 1e-9) return p1;
            const t = -(a * p1.x + b * p1.y + c) / denominator; return { x: p1.x + t * dx, y: p1.y + t * dy };
        }
        function createEliminationZone(prevBar, currentBar, isWarmer) {
            const rect = { x: GAME_BOUNDS.west, y: GAME_BOUNDS.south, width: GAME_BOUNDS.east - GAME_BOUNDS.west, height: GAME_BOUNDS.north - GAME_BOUNDS.south };
            const pointToEliminate = isWarmer ? prevBar : currentBar; const pointToKeep = isWarmer ? currentBar : prevBar;
            const pointA_xy = { x: pointToEliminate.lng, y: pointToEliminate.lat }; const pointB_xy = { x: pointToKeep.lng, y: pointToKeep.lat };
            const polygonVertices = getRectangleSlice(rect, pointA_xy, pointB_xy); if (polygonVertices.length < 3) return null;
            const leafletCoords = polygonVertices.map(p => [p.y, p.x]);
            const zone = L.polygon(leafletCoords, { color: '#dc2626', weight: 1, fillColor: '#ef4444', fillOpacity: 0.2 }).addTo(map);
            eliminationZones.push(zone);
        }

        // --- GAME LOGIC ---
        function distance(p1, p2) { return Math.sqrt(Math.pow(p1.lat - p2.lat, 2) + Math.pow(p1.lng - p2.lng, 2)); }
        
        async function geocodeLocation(query) {
            const centerLat = (GAME_BOUNDS.north + GAME_BOUNDS.south) / 2;
            const centerLng = (GAME_BOUNDS.east + GAME_BOUNDS.west) / 2;
            const url = `https://photon.komoot.io/api/?q=${encodeURIComponent(query)}&lon=${centerLng}&lat=${centerLat}&limit=1`;
            const response = await fetch(url); 
            if (!response.ok) throw new Error('Network error');
            const data = await response.json(); 
            if (!data.features || data.features.length === 0) throw new Error(`'${query}' not found`);
            const { coordinates } = data.features[0].geometry; 
            return { lat: coordinates[1], lng: coordinates[0] };
        }

        async function fetchBarsInBounds() {
            const overpassUrl = 'https://overpass-api.de/api/interpreter';
            const query = `
                [out:json][timeout:25];
                (
                  node["amenity"="bar"](${GAME_BOUNDS.south},${GAME_BOUNDS.west},${GAME_BOUNDS.north},${GAME_BOUNDS.east});
                  node["amenity"="pub"](${GAME_BOUNDS.south},${GAME_BOUNDS.west},${GAME_BOUNDS.north},${GAME_BOUNDS.east});
                );
                out body;
            `;
            
            const response = await fetch(overpassUrl, {
                method: 'POST',
                body: query
            });
            
            if (!response.ok) throw new Error('Failed to fetch bars from OpenStreetMap');
            const data = await response.json();
            
            const bars = data.elements
                .filter(el => el.tags && el.tags.name)
                .map(el => ({
                    name: el.tags.name,
                    lat: el.lat,
                    lng: el.lon
                }));
            
            if (bars.length < 2) {
                throw new Error('Fewer than 2 bars found in the area. Please select a larger or different location.');
            }
            
            return bars;
        }

        function showMessage(text, type) { const msgDiv = document.getElementById('message'); msgDiv.textContent = text; msgDiv.className = `message ${type}`; if (type !== 'win') { setTimeout(() => { msgDiv.textContent = ''; msgDiv.className = ''; }, 3000); } }
        function updatePath() { if (pathLine) map.removeLayer(pathLine); if (gameState.visitedBars.length > 0) { const points = [ [gameState.startingPoint.lat, gameState.startingPoint.lng], ...gameState.visitedBars.map(bar => [bar.lat, bar.lng]) ]; pathLine = L.polyline(points, { color: '#667eea', weight: 3, opacity: 0.7, dashArray: '10, 10' }).addTo(map); } }

        async function initGame() {
            if (map) { map.remove(); map = null; }
            map = L.map('map').setView([centerLocation.lat, centerLocation.lng], 14);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap contributors', maxZoom: 19 }).addTo(map);
            
            markers.forEach(marker => marker.remove()); markers = [];
            if (pathLine) pathLine.remove(); pathLine = null;
            eliminationZones.forEach(zone => zone.remove()); eliminationZones = [];
            clearPreview();

            // FIX 1: Fetch bars once and store them
            showMessage('Searching for bars in the area...', 'success');
            try {
                allBarsInArea = await fetchBarsInBounds();
            } catch (error) {
                showMessage(error.message, 'error');
                setTimeout(resetGame, 3000); 
                return;
            }
            const bars = allBarsInArea; // Use the global list for setup

            const targetBar = bars[Math.floor(Math.random() * bars.length)];
            
            gameArea = L.rectangle([[GAME_BOUNDS.south, GAME_BOUNDS.west], [GAME_BOUNDS.north, GAME_BOUNDS.east]], { color: '#667eea', weight: 2, fillOpacity: 0.1, dashArray: '5, 5' }).addTo(map);
            gameArea.bindPopup('Game Area - Find bars within this zone!');

            gameState.targetBar = targetBar.name; 
            gameState.targetLocation = { lat: targetBar.lat, lng: targetBar.lng };
            gameState.visitedBars = []; gameState.visitCount = 0; gameState.gameWon = false;

            const startMarker = L.marker([gameState.startingPoint.lat, gameState.startingPoint.lng], { icon: startIcon }).addTo(map);
            startMarker.bindPopup(`<div class="bar-popup"><h3>🏁 Starting Point</h3><p>${gameState.startingPoint.name}</p></div>`);
            markers.push(startMarker);

            document.getElementById('targetBar').textContent = '???';
            document.getElementById('visitCount').textContent = '0';
            document.getElementById('startingBar').textContent = gameState.startingPoint.name;
            barInput.disabled = false; previewBtn.disabled = false;
            showMessage(`Game started! ${bars.length} bars found in area. Find the hidden bar.`, 'success');
            map.fitBounds(gameArea.getBounds(), { padding: [10, 10] });
        }
        
        async function tryBar() {
            if (gameState.gameWon || !previewedLocation) return;
            
            const foundBarName = await findClosestBarName(previewedLocation);
            const location = previewedLocation;
            clearPreview();
            
            const prevLocation = gameState.visitedBars.length > 0 ? gameState.visitedBars[gameState.visitedBars.length - 1] : gameState.startingPoint;
            const currentDist = distance(location, gameState.targetLocation);
            const prevDist = distance(prevLocation, gameState.targetLocation);
            const isWarmer = currentDist < prevDist;
            
            gameState.visitCount++;
            gameState.visitedBars.push({ name: foundBarName, ...location });

            const isWin = foundBarName.toLowerCase() === gameState.targetBar.toLowerCase();
            const icon = isWin ? winIcon : visitedIcon(gameState.visitCount, isWarmer);
            
            const marker = L.marker([location.lat, location.lng], { icon }).addTo(map)
                .bindPopup(`<div class="bar-popup"><h3>${isWin ? '🎉 ' : (isWarmer ? '🔥 ' : '❄️ ')}${foundBarName}</h3><p><span class="visit-number">${gameState.visitCount}</span> Visit #${gameState.visitCount}</p>${!isWin ? `<p style="font-weight: 600; color: ${isWarmer ? '#FF6347' : '#4169E1'}">${isWarmer ? '🔥 Warmer!' : '❄️ Colder!'}</p>` : ''}${isWin ? '<p style="color: #4CAF50; font-weight: 600;">YOU FOUND IT!</p>' : ''}</div>`)
                .openPopup();
            markers.push(marker);
            
            createEliminationZone(prevLocation, location, isWarmer);
            updatePath();
            map.flyTo([location.lat, location.lng], Math.max(map.getZoom(), 16), { duration: 1 });
            document.getElementById('visitCount').textContent = gameState.visitCount;

            if (isWin) {
                gameState.gameWon = true;
                document.getElementById('targetBar').textContent = gameState.targetBar;
                showMessage(`🎉 Congratulations! You found ${gameState.targetBar} in ${gameState.visitCount} tries!`, 'win');
                barInput.disabled = true; previewBtn.disabled = true;
            } else { showMessage(isWarmer ? '🔥 Getting warmer!' : '❄️ Getting colder!', isWarmer ? 'warmer' : 'colder'); }
        }

        // FIX 1: Modified to use the global allBarsInArea list
        async function findClosestBarName(location) {
            const bars = allBarsInArea;
            if (!bars || bars.length === 0) return barInput.value.trim();

            let closestBar = null;
            let minDistance = Infinity;

            for(const bar of bars) {
                const dist = distance(location, bar);
                if (dist < minDistance) {
                    minDistance = dist;
                    closestBar = bar;
                }
            }
            return closestBar ? closestBar.name : barInput.value.trim();
        }

        function setButtonsToPreviewState(isPreviewing) {
            previewBtn.classList.toggle('hidden', isPreviewing);
            confirmBtn.classList.toggle('hidden', !isPreviewing);
            cancelBtn.classList.toggle('hidden', !isPreviewing);
            barInput.disabled = isPreviewing;
        }

        async function previewBar() {
            const query = barInput.value.trim();
            if (!query) { showMessage('Please enter a bar name to preview.', 'error'); return; }
            
            previewBtn.disabled = true;
            previewBtn.textContent = '...';

            try {
                const location = await geocodeLocation(query);
                if (location.lat < GAME_BOUNDS.south || location.lat > GAME_BOUNDS.north || location.lng < GAME_BOUNDS.west || location.lng > GAME_BOUNDS.east) {
                    showMessage(`'${query}' is outside the game area.`, 'error'); return;
                }
                previewedLocation = location;

                const prevLocation = gameState.visitedBars.length > 0 ? gameState.visitedBars[gameState.visitedBars.length - 1] : gameState.startingPoint;
                const prev_xy = { x: prevLocation.lng, y: prevLocation.lat };
                const current_xy = { x: location.lng, y: location.lat };
                const linePoints = getBisectorLinePoints(prev_xy, current_xy);

                if (linePoints.length >= 2) {
                    previewMarker = L.marker([location.lat, location.lng], { icon: previewIcon }).addTo(map);
                    previewLine = L.polyline(linePoints, { color: '#f97316', weight: 4, opacity: 0.8, dashArray: '8, 8' }).addTo(map);
                    map.fitBounds(L.latLngBounds(linePoints).extend(L.latLng(location.lat, location.lng)), { padding: [50, 50], maxZoom: 16 });
                    setButtonsToPreviewState(true);
                } else {
                     showMessage(`Could not determine direction for '${query}'. Try another guess.`, 'error');
                }
            } catch (error) { 
                showMessage(error.message, 'error'); 
            } finally {
                previewBtn.disabled = false;
                previewBtn.textContent = 'Preview';
            }
        }

        function clearPreview() {
            if (previewLine) map.removeLayer(previewLine);
            if (previewMarker) map.removeLayer(previewMarker);
            previewLine = null;
            previewMarker = null;
            previewedLocation = null;
            setButtonsToPreviewState(false);
            barInput.value = '';
            if (!gameState.gameWon) barInput.disabled = false;
        }
        
        function resetGame() {
            gameScreen.classList.add('hidden');
            initialSetupScreen.classList.remove('hidden');
            
            if (map) { map.remove(); map = null; }
            if (boundaryMap) { boundaryMap.remove(); boundaryMap = null; }

            document.getElementById('message').className = '';
            document.getElementById('message').textContent = '';
            barInput.value = '';
            
            selectedSize = 'M';
            document.querySelectorAll('.size-btn').forEach(b => b.classList.remove('selected'));
            document.querySelector('.size-btn[data-size="M"]').classList.add('selected');

            setButtonsToPreviewState(false);
            barInput.disabled = false;
        }

        // --- BOUNDARY SETUP LOGIC ---
        function initBoundaryMap() {
            if (boundaryMap) { boundaryMap.remove(); boundaryMap = null; }
            boundaryMap = L.map('boundaryMap').setView([centerLocation.lat, centerLocation.lng], 13);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }).addTo(boundaryMap);

            updateBoundaryRectangle();
        }

        function updateBoundaryRectangle() {
            const bounds = [[GAME_BOUNDS.south, GAME_BOUNDS.west], [GAME_BOUNDS.north, GAME_BOUNDS.east]];
            
            if (boundaryRectangle) {
                boundaryRectangle.remove();
            }
            boundaryRectangle = L.rectangle(bounds, { 
                color: "#667eea", 
                weight: 3,
            }).addTo(boundaryMap);
            
            boundaryMap.fitBounds(bounds, { padding: [50, 50], maxZoom: 15 });
            updateBoundaryValues();
        }

        function updateBoundaryValues() {
            document.getElementById('northValue').textContent = GAME_BOUNDS.north.toFixed(4);
            document.getElementById('southValue').textContent = GAME_BOUNDS.south.toFixed(4);
            document.getElementById('eastValue').textContent = GAME_BOUNDS.east.toFixed(4);
            document.getElementById('westValue').textContent = GAME_BOUNDS.west.toFixed(4);
        }

        function adjustBoundary(direction, amount) {
            GAME_BOUNDS[direction] += amount;
            
            if (GAME_BOUNDS.north <= GAME_BOUNDS.south + 0.001) {
                GAME_BOUNDS[direction] -= amount;
                return;
            }
            if (GAME_BOUNDS.east <= GAME_BOUNDS.west + 0.001) {
                GAME_BOUNDS[direction] -= amount;
                return;
            }
            
            updateBoundaryRectangle();
        }

        function calculateBoundsFromCenter(center, size) {
            offset = SIZE_PRESETS[size] / 2;
            delta_lat = (offset / 6371) * (180 / Math.PI)
            delta_lon = (offset / 6371) * (180 / Math.PI) / Math.cos(center.lat * Math.PI / 180)
            return {
                north: center.lat + delta_lat,
                south: center.lat - delta_lat,
                east: center.lng + delta_lon,
                west: center.lng - delta_lon
            }
        }

        // --- EVENT LISTENERS ---
        document.querySelectorAll('.size-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.size-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                selectedSize = btn.dataset.size;
            });
        });

        continueBtn.addEventListener('click', async () => {
            const initialSetupError = document.getElementById('initialSetupError');
            initialSetupError.textContent = '';
            continueBtn.disabled = true;
            continueBtn.textContent = 'Loading...';
            
            try {
                const startLocName = document.getElementById('startLocationInput').value.trim();
                if (!startLocName) throw new Error('Please enter a starting location.');
                
                GAME_BOUNDS = calculateBoundsFromCenter(centerLocation, selectedSize);
                const startLocCoords = await geocodeLocation(startLocName);
                gameState.startingPoint = { name: startLocName, ...startLocCoords };
                centerLocation = startLocCoords;
                
                GAME_BOUNDS = calculateBoundsFromCenter(centerLocation, selectedSize);
                
                initialSetupScreen.classList.add('hidden');
                boundarySetupScreen.classList.remove('hidden');
                
                setTimeout(initBoundaryMap, 10);
                
            } catch (error) {
                initialSetupError.textContent = `Error: ${error.message}`;
            } finally {
                continueBtn.disabled = false;
                continueBtn.textContent = 'Continue to Map';
            }
        });

        backBtn.addEventListener('click', () => {
            boundarySetupScreen.classList.add('hidden');
            initialSetupScreen.classList.remove('hidden');
        });

        document.querySelectorAll('.adjust-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const direction = btn.dataset.direction;
                const amount = parseFloat(btn.dataset.amount);
                adjustBoundary(direction, amount);
            });
        });

        startGameBtn.addEventListener('click', async () => {
            const boundaryError = document.getElementById('boundaryError');
            boundaryError.textContent = '';
            startGameBtn.disabled = true;
            startGameBtn.textContent = 'Loading...';
            
            try {
                if (GAME_BOUNDS.north <= GAME_BOUNDS.south || GAME_BOUNDS.east <= GAME_BOUNDS.west) {
                    throw new Error("Invalid boundaries.");
                }

                boundarySetupScreen.classList.add('hidden');
                gameScreen.classList.remove('hidden');
                
                setTimeout(initGame, 10);

            } catch (error) {
                boundaryError.textContent = `Error: ${error.message}`;
                startGameBtn.disabled = false;
                startGameBtn.textContent = 'Start Game';
            } finally {
                 setTimeout(() => {
                    startGameBtn.disabled = false;
                    startGameBtn.textContent = 'Start Game';
                }, 1000);
            }
        });

        previewBtn.addEventListener('click', previewBar);
        confirmBtn.addEventListener('click', tryBar);
        cancelBtn.addEventListener('click', clearPreview);
        resetBtn.addEventListener('click', resetGame);
        barInput.addEventListener('keypress', (e) => { 
            if (e.key === 'Enter' && !previewBtn.classList.contains('hidden')) {
                previewBtn.click();
            }
        });

    </script>
</body>
</html>
