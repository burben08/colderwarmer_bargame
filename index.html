<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bar Hunt</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css"
    />
    <link rel="stylesheet" href="styles.css" />
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
  </head>
  <body>
    <div id="initialSetupScreen">
      <div class="initial-setup-card">
        <h1>üç∫ Find the Secret Bar</h1>

        <!-- Section 1: Starting Location -->
        <div class="setup-section active" data-section="location">
          <div class="section-header">
            <div class="section-title">
              <span class="section-icon">üìç</span>
              <span>Starting Location</span>
            </div>
            <span class="section-arrow">‚ñº</span>
          </div>
          <div class="section-content">
            <div class="section-inner">
              <input
                type="text"
                id="startLocationInput"
                class="setup-input"
                value="Paradeplatz, Zurich"
                placeholder="Enter a location..."
              />
            </div>
          </div>
        </div>

        <!-- Section 2: Game Boundary -->
        <div class="setup-section" data-section="boundary">
          <div class="section-header">
            <div class="section-title">
              <span class="section-icon">üó∫Ô∏è</span>
              <span>Game Boundary</span>
            </div>
            <span class="section-arrow">‚ñº</span>
          </div>
          <div class="section-content">
            <div class="section-inner">
              <div class="tab-nav">
                <button class="tab-btn active" data-tab="custom">
                  Custom Size
                </button>
                <button class="tab-btn" data-tab="region">Region</button>
              </div>

              <div class="tab-content active" data-tab-content="custom">
                <div class="size-grid">
                  <button class="size-btn" data-size="S">S</button>
                  <button class="size-btn selected" data-size="M">M</button>
                  <button class="size-btn" data-size="L">L</button>
                  <button class="size-btn" data-size="XL">XL</button>
                  <button class="size-btn" data-size="XXL">XXL</button>
                  <button class="size-btn" data-size="XXXL">XXXL</button>
                </div>
              </div>

              <div class="tab-content" data-tab-content="region">
                <div class="region-grid">
                  <button class="region-btn" data-size="Switzerland">
                    üá®üá≠ Switzerland
                  </button>
                  <button class="region-btn" data-size="Germany">
                    üá©üá™ Germany
                  </button>
                  <button class="region-btn" data-size="France">
                    üá´üá∑ France
                  </button>
                  <button class="region-btn" data-size="Italy">üáÆüáπ Italy</button>
                  <button class="region-btn" data-size="Austria">
                    üá¶üáπ Austria
                  </button>
                  <button class="region-btn" data-size="Spain">üá™üá∏ Spain</button>
                  <button class="region-btn" data-size="Europe">
                    üá™üá∫ Europe
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Section 3: Advanced -->
        <div class="setup-section" data-section="advanced">
          <div class="section-header">
            <div class="section-title">
              <span class="section-icon">‚öôÔ∏è</span>
              <span>Advanced</span>
            </div>
            <span class="section-arrow">‚ñº</span>
          </div>

          <div class="section-content">
            <div class="section-inner">
              <h3 class="sub-title">üë≠ Play on multiple Phones</h3>
              <input
                type="text"
                id="gameCodeInput"
                class="setup-input"
                placeholder="Paste game code to copy game (optional)"
              />
              <div class="seed-helper">
                By clicking on the 'üë≠' icon in the game another user can send
                you the game code, so you can play the exact same game.
              </div>
            </div>

            <div class="section-inner">
              <h3 class="sub-title">
                üç¥ Also include Restaurants
              </h3>
              <label class="checkbox-container">
                Yes
                <input type="checkbox" id="restaurantCheckbox" />
                <span class="checkmark"></span>
              </label>
            </div>

            <div class="section-inner">
              <h3 class="sub-title">‚è≥ Open for at least</h3>
              <select class="dropdown-select" id="minimumOpenFor">
                <option value="none">-</option>
                <option value="now">Now</option>
                <option value="1">1h</option>
                <option value="2">2h</option>
                <option value="3">3h</option>
                <option value="4">4h</option>
                <option value="5">5h</option>
                <option value="6">6h</option>
              </select>
              <div class="seed-helper">
                This reduces the considered bars drastically, since many dont
                have opening hours listed. Also the listed hours may be
                inaccurate.
              </div>
            </div>
          </div>
        </div>

        <div id="initialSetupError"></div>
        <button id="continueBtn">Continue to Map</button>
      </div>
    </div>

    <div id="boundarySetupScreen" class="hidden">
      <div class="boundary-controls">
        <button id="backBtn">‚Üê Back</button>
        <h2>Adjust Game Area</h2>
        <p>Fine-tune the boundaries of the game area.</p>
        <div class="boundary-adjust">
          <div class="boundary-row">
            <label>North</label>
            <button class="adjust-btn" data-direction="north" data-amount="">
              ‚àí
            </button>
            <span class="boundary-value" id="northValue">0</span>
            <button class="adjust-btn" data-direction="north" data-amount="">
              +
            </button>
          </div>
          <div class="boundary-row">
            <label>South</label>
            <button class="adjust-btn" data-direction="south" data-amount="">
              ‚àí
            </button>
            <span class="boundary-value" id="southValue">0</span>
            <button class="adjust-btn" data-direction="south" data-amount="">
              +
            </button>
          </div>
          <div class="boundary-row">
            <label>East</label>
            <button class="adjust-btn" data-direction="east" data-amount="">
              ‚àí
            </button>
            <span class="boundary-value" id="eastValue">0</span>
            <button class="adjust-btn" data-direction="east" data-amount="">
              +
            </button>
          </div>
          <div class="boundary-row">
            <label>West</label>
            <button class="adjust-btn" data-direction="west" data-amount="">
              ‚àí
            </button>
            <span class="boundary-value" id="westValue">0</span>
            <button class="adjust-btn" data-direction="west" data-amount="">
              +
            </button>
          </div>
        </div>
        <div id="boundaryError"></div>
        <button id="startGameBtn">Start Game</button>
      </div>
      <div id="boundaryMap"></div>
    </div>

    <div id="gameScreen" class="hidden">
      <div class="header">
        <button id="resetBtn" title="New Game">
          <svg viewBox="0 0 24 24">
            <path
              d="M17.65,6.35C16.2,4.9,14.21,4,12,4A8,8,0,0,0,4,12A8,8,0,0,0,12,20C15.73,20,18.84,17.45,19.73,14H17.65C16.83,16.33,14.61,18,12,18A6,6,0,0,1,6,12A6,6,0,0,1,12,6C13.55,6,14.93,6.6,15.96,7.65L13,10.61H20V3.61L17.65,6.35Z"
            ></path>
          </svg>
        </button>
        <button id="seedInfoBtn" title="Show Seed">üë≠</button>
        <h1>üç∫ Find the Secret Bar</h1>
        <div class="game-info">
          <!--<span>üéØ Target: <strong id="targetBar">???</strong></span>-->
          <span>üó∫Ô∏è Map Size: <strong id="mapSize">M</strong></span>
          <span>üèÉ Visits: <strong id="visitCount">0</strong></span>
          <span
            >üìç Starting Point:
            <strong id="startingBar">Paradeplatz</strong></span
          >
          <!--<span>Bars Remaining: <strong id="remainingBars">???</strong></span>-->
        </div>
        <div class="search-container">
          <input
            type="text"
            id="barInput"
            class="search-input"
            placeholder="Enter a bar name..."
            autocomplete="off"
          />
          <button id="previewBtn" class="btn btn-primary">Preview</button>
          <button id="confirmBtn" class="btn btn-confirm hidden">
            Confirm Guess
          </button>
          <button id="cancelBtn" class="btn btn-cancel hidden">Cancel</button>
        </div>
        <div id="message"></div>
      </div>
      <div id="map"></div>
    </div>

    <div id="seedPopup" class="popupHidden">
      <div class="popupContent">
        <button id="popupClose" class="popupCloseBtn">‚úñ</button>

        <h2>Copy Game Settings</h2>

        <div class="seed-helper">
          Share this code with a friend to let them play the same game:
        </div>

        <div class="popupSection">
          <div class="popupHeader">
            <strong>Game Code</strong>
            <button class="copyBtn" data-copy-target="popupCode">Copy</button>
          </div>
          <div id="popupCode" class="popupValue"></div>
        </div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/seedrandom@3.0.5/seedrandom.min.js"></script>
    <script type="module">
      // IMPORTS
      import {
        buildPolygon,
        getLineCoordsBetween,
        getIntersections,
        sphericalDistance,
        lonLatToCartesian,
      } from "./SphericalPolygon.js";
      import {
        createEliminationZone,
        isPointInPolygon,
      } from "./PlanarPolygon.js";
      import { drawRandomBarFromDensityGrid } from "./GlobalBarSelection.js";
      import { GAME_BOUNDS_Regions } from "./GameBounds.js";

      // Make the function global so other scripts can see it
      window.buildPolygon = buildPolygon;
      window.createEliminationZone = createEliminationZone;
      window.getLineCoordsBetween = getLineCoordsBetween;
      window.getIntersections = getIntersections;
      window.isPointInPolygon = isPointInPolygon;
      window.sphericalDistance = sphericalDistance;
      window.lonLatToCartesian = lonLatToCartesian;

      window.drawRandomBarFromDensityGrid = drawRandomBarFromDensityGrid;

      window.GAME_BOUNDS_Regions = GAME_BOUNDS_Regions;
    </script>
    <script>
      // --- DOM ELEMENTS ---
      const initialSetupScreen = document.getElementById("initialSetupScreen");
      const boundarySetupScreen = document.getElementById(
        "boundarySetupScreen"
      );
      const gameScreen = document.getElementById("gameScreen");
      const continueBtn = document.getElementById("continueBtn");
      const startGameBtn = document.getElementById("startGameBtn");
      const backBtn = document.getElementById("backBtn");
      const barInput = document.getElementById("barInput");
      const previewBtn = document.getElementById("previewBtn");
      const confirmBtn = document.getElementById("confirmBtn");
      const cancelBtn = document.getElementById("cancelBtn");
      const resetBtn = document.getElementById("resetBtn");

      const restaurantCheckbox = document.getElementById("restaurantCheckbox");

      // --- SIZE PRESETS ---
      const SIZE_PRESETS = {
        S: 1, //km
        M: 2,
        L: 4,
        XL: 10,
        XXL: 50,
        XXXL: 500,
      };

      const STEP_SIZES = Object.fromEntries(
        Object.entries(SIZE_PRESETS).map(([key, value]) => [key, value / 10000]) // 1 km ‚âà 0.01¬∞, so 1/100 km ‚âà 0.0001¬∞
      );

      // --- GAME STATE & VARS ---
      let centerLocation = { lat: 47.3769, lng: 8.5417 };
      //let GAME_BOUNDS = { south: 47.365, north: 47.39, west: 8.52, east: 8.56 };

      let gameState = {
        targetBar: null,
        targetLocation: null,
        visitedBars: [],
        visitCount: 0,
        gameWon: false,
        startingPoint: { name: "Paradeplatz", lat: 47.3697, lng: 8.5392 },
        selectedSize: "M",
        selectedMode: "custom",
        restaurantsConsidered: false,
        minimumOpenFor: null,
        GAME_BOUNDS: { south: 47.365, north: 47.39, west: 8.52, east: 8.56 },
        SEED: null,
      };

      let allBarsInArea = []; // FIX 1: To store bars and prevent re-fetching
      let previewedLocation = null;
      let map = null;
      let boundaryMap = null;
      let boundaryRectangle = null;
      let gameArea = null;
      let markers = [];
      let pathLine = null;
      let eliminationZones = [];
      let remainingBarsEveryTurn = []; // INSIDE
      let previewLine = null;
      let previewMarker = null;
      //let SEED = null;

      // --- ICONS ---
      const visitedIcon = (number, isWarmer) =>
        L.divIcon({
          html: `<div style="background: ${
            isWarmer ? "#e53e3e" : "#4169E1"
          }; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: 600; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">${number}</div>`,
          className: "",
          iconSize: [32, 32],
          iconAnchor: [16, 16],
          popupAnchor: [0, -16],
        });
      const winIcon = L.divIcon({
        html: '<div style="background: #4CAF50; color: white; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px; border: 3px solid white; box-shadow: 0 2px 12px rgba(0,0,0,0.4); animation: pulse 1s infinite;">üéâ</div><style>@keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); }}</style>',
        className: "",
        iconSize: [40, 40],
        iconAnchor: [20, 20],
        popupAnchor: [0, -20],
      });
      /**
      const startIcon = L.divIcon({
        html: '<div style="background: #FFA500; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 18px; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">üìç</div>',
        className: "",
        iconSize: [32, 32],
        iconAnchor: [16, 16],
        popupAnchor: [0, -16],
      });
      **/
      const startIcon = L.divIcon({
        html: '<div style="font-size: 32px;">üìç</div>',
        className: "",
        iconSize: [24, 24],
        iconAnchor: [12, 24],
        popupAnchor: [0, -24],
      });
      const previewIcon = L.divIcon({
        html: '<div style="background: #757575; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 18px; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">?</div>',
        className: "",
        iconSize: [32, 32],
        iconAnchor: [16, 16],
      });

      // --- GAME LOGIC ---
      async function geocodeLocation(query, bounds = null) {
        let url;
        if (bounds) {
          // Compute center and bias search around visible map area
          const centerLat = (bounds.north + bounds.south) / 2;
          const centerLng = (bounds.east + bounds.west) / 2;

          // Photon supports lat/lon biasing + bounding box via "bbox"
          url = `https://photon.komoot.io/api/?q=${encodeURIComponent(
            query
          )}&lat=${centerLat}&lon=${centerLng}&bbox=${bounds.west},${
            bounds.south
          },${bounds.east},${bounds.north}&limit=1`;
        } else {
          // fallback global search
          const centerLat =
            (gameState.GAME_BOUNDS.north + gameState.GAME_BOUNDS.south) / 2;
          const centerLng =
            (gameState.GAME_BOUNDS.east + gameState.GAME_BOUNDS.west) / 2;
          url = `https://photon.komoot.io/api/?q=${encodeURIComponent(
            query
          )}&lat=${centerLat}&lon=${centerLng}&limit=1`;
        }

        const response = await fetch(url);
        if (!response.ok) throw new Error("Network error");
        const data = await response.json();
        if (!data.features || data.features.length === 0) return null;

        const name = data.features[0].properties.name;
        const { coordinates } = data.features[0].geometry;
        return {
          location: { lat: coordinates[1], lng: coordinates[0] },
          name,
        };
      }

      async function fetchBarsInBounds() {
        const overpassUrl = "https://overpass-api.de/api/interpreter";

        const locationTypes = ["bar", "pub"];
        if (gameState.restaurantsConsidered) locationTypes.push("restaurant");

        const bounds = `${gameState.GAME_BOUNDS.south},${gameState.GAME_BOUNDS.west},${gameState.GAME_BOUNDS.north},${gameState.GAME_BOUNDS.east}`;

        const query = `
        [out:json][timeout:100];
        (
          ${locationTypes
            .map((a) => `node["amenity"="${a}"](${bounds});`)
            .join("\n    ")}
        );
        out body;
      `;

        const response = await fetch(overpassUrl, {
          method: "POST",
          body: query,
        });

        if (!response.ok)
          throw new Error(
            "Failed to fetch bars from OpenStreetMap. Try again."
          );
        const data = await response.json();

        // DATE FILTER:
        const now = new Date();

        const bars = data.elements
          .filter((el) => el.tags && el.tags.name)
          .map((el) => ({
            name: el.tags.name,
            city: el.tags["addr:city"] || "",
            lat: el.lat,
            lng: el.lon,
            inside: true,
            openingHours: el.tags.opening_hours || null,
          }))
          // CHANGED: Only filter if minimumOpenFor is not null/undefined
          .filter((bar) => {
            if (gameState.minimumOpenFor == null) return true; // No filtering if null/undefined
            return isBarOpenAtTime(
              bar.openingHours,
              now,
              gameState.minimumOpenFor,
              bar.name
            );
          });

        if (bars.length < 2) {
          throw new Error(
            "Fewer than 2 bars found in the area. Please select a larger or different location."
          );
        }

        return bars;
      }

      // CHANGED: Added mode parameter to handle 'today' vs number filtering
      function isBarOpenAtTime(
        openingHours,
        checkTime, // This is 'now' passed from fetchBarsInBounds
        minimumOpenFor,
        barName
      ) {
        if (!openingHours) {
          console.log(`Bar "${barName}" has no opening hours.`);
          return false;
        }

        try {
          // --- 1. Parse today's hours (same logic as your code) ---
          const dayNames = ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"];
          // Use checkTime, not a new Date(), to be consistent
          const todayName = dayNames[checkTime.getDay()];
          const normalized = openingHours.toLowerCase().replace(/\s+/g, " ");
          let todayHours = null;

          const dayRangeMatch = normalized.match(
            /([a-z,\-]+)\s+(\d{1,2}:\d{2})\s*-\s*(\d{1,2}:\d{2})/
          );
          if (dayRangeMatch) {
            const days = dayRangeMatch[1];
            const openTimeStr = dayRangeMatch[2];
            const closeTimeStr = dayRangeMatch[3];
            if (
              days.includes(todayName.toLowerCase()) ||
              days === "mo-su" ||
              days === "daily"
            ) {
              todayHours = { open: openTimeStr, close: closeTimeStr };
            }
          } else {
            const simpleMatch = normalized.match(
              /(\d{1,2}:\d{2})\s*-\s*(\d{1,2}:\d{2})/
            );
            if (simpleMatch) {
              todayHours = { open: simpleMatch[1], close: simpleMatch[2] };
            }
          }

          if (!todayHours) {
            // console.log(`Bar "${barName}" has no parseable hours for today. Keeping.`);
            return true; // Can't parse for today = don't filter out
          }

          // --- 2. Calculate Date objects for open/close times ---
          const parseTime = (timeStr) => {
            const [h, m] = timeStr.split(":").map(Number);
            const d = new Date(checkTime); // Start with the correct date
            d.setHours(h, m, 0, 0);
            return d;
          };

          const openTime = parseTime(todayHours.open);
          const closeTime = parseTime(todayHours.close);

          // Handle closing after midnight (e.g., 22:00-02:00)
          if (closeTime < openTime) {
            closeTime.setDate(closeTime.getDate() + 1);
          }

          // --- 3. Check if the bar is open RIGHT NOW ---
          // Note: This logic doesn't handle cases where the bar opened *yesterday* // and is still open (e.g., it's 1 AM, hours are Mo 22:00-02:00).
          // Your simple parser doesn't support that, so we'll stick to this:
          const isOpenNow = checkTime >= openTime && checkTime <= closeTime;

          // --- 4. Apply filter logic based on 'minimumOpenFor' ---

          // Case: 'now'
          if (minimumOpenFor === "now") {
            if (!isOpenNow) {
              console.log(`Bar "${barName}" is filtered out (not open now).`);
            }
            return isOpenNow; // Keep if open, filter if closed
          }

          // Case: integer
          if (typeof minimumOpenFor === "number") {
            // Must be open *now* to even be considered
            if (!isOpenNow) {
              console.log(
                `Bar "${barName}" is filtered out (not open now for duration check).`
              );
              return false;
            }

            // If it is open, check if it stays open long enough
            const requiredOpenUntil = new Date(
              checkTime.getTime() + minimumOpenFor * 60 * 60 * 1000
            );

            if (requiredOpenUntil > closeTime) {
              console.log(
                `Bar "${barName}" is filtered out (closes at ${closeTime}, required until ${requiredOpenUntil}).`
              );
              return false; // Won't be open long enough
            }

            // Passes both checks!
            return true;
          }

          // Failsafe, though 'none' (null) is handled in the .filter()
          return true;
        } catch (e) {
          console.warn(
            `Error parsing opening hours for "${barName}": ${openingHours}`,
            e
          );
          return true; // Error parsing = don't filter out
        }
      }

      function showMessage(text, type) {
        const msgDiv = document.getElementById("message");
        msgDiv.textContent = text;
        msgDiv.className = `message ${type}`;
        if (type !== "win") {
          setTimeout(() => {
            msgDiv.textContent = "";
            msgDiv.className = "";
          }, 3000);
        }
      }

      function openSeedPopup(code) {
        document.getElementById("popupCode").textContent = code;

        const popup = document.getElementById("seedPopup");
        popup.classList.remove("popupHidden");
      }

      function closeSeedPopup() {
        document.getElementById("seedPopup").classList.add("popupHidden");
      }

      function updatePath() {
        if (pathLine) map.removeLayer(pathLine);
        if (gameState.visitedBars.length > 0) {
          const points = [
            [gameState.startingPoint.lat, gameState.startingPoint.lng],
            ...gameState.visitedBars.map((bar) => [bar.lat, bar.lng]),
          ];
          pathLine = L.polyline(points, {
            color: "#667eea",
            weight: 3,
            opacity: 0.7,
            dashArray: "8, 6",
          }).addTo(map);
        }
      }

      async function initGame() {
        if (map) {
          map.remove();
          map = null;
        }
        map = L.map("map").setView(
          [centerLocation.lat, centerLocation.lng],
          14
        );
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          attribution: "¬© OpenStreetMap contributors",
          maxZoom: 19,
        }).addTo(map);

        markers.forEach((marker) => marker.remove());
        markers = [];
        if (pathLine) pathLine.remove();
        pathLine = null;
        eliminationZones.forEach((zone) => zone.remove());
        eliminationZones = [];
        clearPreview();

        // Set Seed
        if (!gameState.SEED) {
          gameState.SEED = Math.random().toString(36).substring(2, 10);
        }

        // FIX 1: Fetch bars once and store them
        showMessage("Searching for bars in the area...", "success");
        try {
          if (gameState.selectedMode === "region") {
            allBarsInArea = await drawRandomBarFromDensityGrid(
              gameState.GAME_BOUNDS,
              gameState.SEED
            );
          } else {
            allBarsInArea = await fetchBarsInBounds();
          }
        } catch (error) {
          showMessage(error.message, "error");
          setTimeout(resetGame, 2000);
          return;
        }
        const bars = allBarsInArea; // Use the global list for setup

        // INSIDE: Display all bars on map (for testing)
        if (gameState.SEED == "Hacker") {
          bars.forEach((bar) => {
            const icon = L.divIcon({
              html: '<div style="background:red;width:12px;height:12px;border-radius:50%;border:2px solid white;"></div>',
              className: "",
            });

            const marker = L.marker([bar.lat, bar.lng], { icon }).addTo(map);
            marker.bindPopup(
              `<div class="bar-popup"><h3>${bar.name}</h3></div>`
            );
            marker.on("click", () => {
              marker.openPopup();
              const input = document.getElementById("barInput");
              if (input) input.value = bar.name;
            });

            markers.push(marker);
          });
        }

        const rng = new Math.seedrandom(gameState.SEED);
        const targetBar = bars[Math.floor(rng() * bars.length)];

        console.log("Target Bar: ", targetBar.name, targetBar.city);
        console.log("Target city: ", targetBar.city);
        console.log("Seed: ", gameState.SEED);

        gameArea = L.rectangle(
          [
            [gameState.GAME_BOUNDS.south, gameState.GAME_BOUNDS.west],
            [gameState.GAME_BOUNDS.north, gameState.GAME_BOUNDS.east],
          ],
          { color: "#eb5e4b", weight: 2, fillOpacity: 0.05, dashArray: "5, 5" }
        ).addTo(map);
        gameArea.bindPopup("Game Area - Find bars within this zone!");

        gameState.targetBar = targetBar.name;
        gameState.targetLocation = { lat: targetBar.lat, lng: targetBar.lng };

        const startMarker = L.marker(
          [gameState.startingPoint.lat, gameState.startingPoint.lng],
          { icon: startIcon }
        ).addTo(map);
        startMarker.bindPopup(
          `<div class="bar-popup"><h3>üìç Starting Point</h3><p>${gameState.startingPoint.name}</p></div>`
        );
        markers.push(startMarker);

        // INSIDE
        /**
        if (SEED == "Hacker") {
          const remainingBars = allBarsInArea.filter(
            (bar) => bar.inside
          ).length;
          remainingBarsEveryTurn.push(remainingBars);
          document.getElementById(
            "remainingBars"
          ).textContent = `${remainingBars}/${bars.length}`;
        }
          **/

        //document.getElementById("targetBar").textContent = "???";
        document.getElementById("visitCount").textContent = "0";
        document.getElementById("startingBar").textContent =
          gameState.startingPoint.name;
        barInput.disabled = false;
        previewBtn.disabled = false;
        document.getElementById("mapSize").textContent = gameState.selectedSize;

        showMessage(
          `Game started! ${bars.length} bars found in area. Find the hidden bar.`,
          "success"
        );
        map.fitBounds(gameArea.getBounds(), { padding: [10, 10] });
      }

      async function confirmBar() {
        if (gameState.gameWon || !previewedLocation) return;

        //const userEnteredName = barInput.value.trim();
        //const foundBarName = await findClosestBarName(previewedLocation);
        const foundBarName = previewedLocation.name;
        const location = previewedLocation.location;
        clearPreview();

        const prevLocation =
          gameState.visitedBars.length > 0
            ? gameState.visitedBars[gameState.visitedBars.length - 1]
            : gameState.startingPoint;
        const p1_xy = lonLatToCartesian(prevLocation.lng, prevLocation.lat);
        const p2_xy = lonLatToCartesian(location.lng, location.lat);
        const target_xy = lonLatToCartesian(
          gameState.targetLocation.lng,
          gameState.targetLocation.lat
        );
        const currentDist = sphericalDistance(p2_xy, target_xy);
        const prevDist = sphericalDistance(p1_xy, target_xy);
        const isWarmer = currentDist < prevDist;

        gameState.visitCount++;
        //gameState.visitedBars.push({ name: foundBarName, ...location });
        gameState.visitedBars.push({ name: foundBarName, ...location });

        const isWin =
          foundBarName.toLowerCase() === gameState.targetBar.toLowerCase();
        const icon = isWin
          ? winIcon
          : visitedIcon(gameState.visitCount, isWarmer);

        const marker = L.marker([location.lat, location.lng], { icon });

        try {
          marker.addTo(map);
        } catch (err) {
          console.error('Failed to add marker:', err);
        }

        marker.bindPopup(
          `<div class="bar-popup"><h3>${
            isWin ? "üéâ " : isWarmer ? "üî• " : "‚ùÑÔ∏è "
          }${foundBarName}</h3><p><span class="visit-number">${
            gameState.visitCount
          }</span> Visit #${gameState.visitCount}</p>${
            !isWin
              ? `<p style="font-weight: 600; color: ${
                  isWarmer ? "#FF6347" : "#4169E1"
                }">${isWarmer ? "üî• Warmer!" : "‚ùÑÔ∏è Colder!"}</p>`
              : ""
          }${
            isWin
              ? '<p style="color: #4CAF50; font-weight: 600;">YOU FOUND IT!</p>'
              : ""
          }</div>`
        );

        marker.openPopup();
        markers.push(marker);

        // Build elimination zone

        const pt1LonLat = [prevLocation.lng, prevLocation.lat];
        const pt2LonLat = [location.lng, location.lat];

        let eliminationZone;

        eliminationZone = window.buildPolygon(
          gameState.GAME_BOUNDS,
          [pt1LonLat, pt2LonLat],
          isWarmer
        );

        const leafletCoords = eliminationZone.map((c) => [c[1], c[0]]);
        const zone = L.polygon(leafletCoords, {
          color: "#667eea",
          weight: 1,
          fillColor: "#4f6df1",
          fillOpacity: 0.1,
        }).addTo(map);
        eliminationZones.push(zone);

        // INSIDE: Update bars inside elimination zones
        if (gameState.SEED == "Hacker") {
          allBarsInArea.forEach((bar) => {
            if (bar.inside) {
              const point = { lat: bar.lat, lng: bar.lng };
              if (window.isPointInPolygon(point, eliminationZone)) {
                bar.inside = false;
              }
            }
          });
        }

        updatePath();
        map.flyTo([location.lat, location.lng], map.getZoom(), {
          duration: 1,
        });
        document.getElementById("visitCount").textContent =
          gameState.visitCount;

        if (isWin) {
          gameState.gameWon = true;
          /**
          document.getElementById("targetBar").textContent =
            gameState.targetBar;
            **/
          showMessage(
            `üéâ Congratulations! You found ${gameState.targetBar} in ${gameState.visitCount} tries!`,
            "win"
          );
          barInput.disabled = true;
          previewBtn.disabled = true;
        } else {
          showMessage(
            isWarmer ? "üî• Getting warmer!" : "‚ùÑÔ∏è Getting colder!",
            isWarmer ? "warmer" : "colder"
          );
          // INSIDE
          /**
          if (SEED == "Hacker") {
            const remainingBars = allBarsInArea.filter(
              (bar) => bar.inside
            ).length;
            remainingBarsEveryTurn.push(remainingBars);
            document.getElementById(
              "remainingBars"
            ).textContent = `${remainingBars}/${allBarsInArea.length}`;
          }
            **/
        }
      }

      // FIX 1: Modified to use the global allBarsInArea list
      async function findClosestBarName(location) {
        const bars = allBarsInArea;
        if (!bars || bars.length === 0) return barInput.value.trim();

        let closestBar = null;
        let minDistance = Infinity;

        for (const bar of bars) {
          const p1_xy = lonLatToCartesian(location.lng, location.lat);
          const p2_xy = lonLatToCartesian(bar.lng, bar.lat);
          const dist = sphericalDistance(p1_xy, p2_xy);
          if (dist < minDistance) {
            minDistance = dist;
            closestBar = bar;
          }
        }
        return closestBar ? closestBar.name : barInput.value.trim();
      }

      function setButtonsToPreviewState(isPreviewing) {
        previewBtn.classList.toggle("hidden", isPreviewing);
        confirmBtn.classList.toggle("hidden", !isPreviewing);
        cancelBtn.classList.toggle("hidden", !isPreviewing);
        barInput.disabled = isPreviewing;
      }

      async function previewBar() {
        const query = barInput.value.trim();
        if (!query) {
          showMessage("Please enter a bar name to preview.", "error");
          return;
        }

        previewBtn.disabled = true;
        previewBtn.textContent = "...";

        try {
          const mapWindow = map.getBounds();
          const currentBounds = {
            north: mapWindow.getNorth(),
            south: mapWindow.getSouth(),
            east: mapWindow.getEast(),
            west: mapWindow.getWest(),
          };

          // try searching within current map window first
          let bar = await geocodeLocation(query, currentBounds);
          if (!bar) {
            bar = await geocodeLocation(query, null);
          }
          if (
            bar.location.lat < gameState.GAME_BOUNDS.south ||
            bar.location.lat > gameState.GAME_BOUNDS.north ||
            bar.location.lng < gameState.GAME_BOUNDS.west ||
            bar.location.lng > gameState.GAME_BOUNDS.east
          ) {
            showMessage(`'${query}' is outside the game area.`, "error");
            return;
          }
          // Save found bar for confirmation
          previewedLocation = bar;

          const prevLocation =
            gameState.visitedBars.length > 0
              ? gameState.visitedBars[gameState.visitedBars.length - 1]
              : gameState.startingPoint;

          const p1_lonlat = [prevLocation.lng, prevLocation.lat];
          const p2_lonlat = [bar.location.lng, bar.location.lat];
          const p1_xy = window.lonLatToCartesian(
            prevLocation.lng,
            prevLocation.lat
          );
          const p2_xy = window.lonLatToCartesian(
            bar.location.lng,
            bar.location.lat
          );
          const boundaryIntersections = window.getIntersections(
            p1_lonlat,
            p2_lonlat,
            gameState.GAME_BOUNDS
          );
          const linePoints = window.getLineCoordsBetween(
            boundaryIntersections[0],
            boundaryIntersections[1]
          );
          const leafletCoords = linePoints.map((c) => [c[1], c[0]]);

          if (linePoints.length >= 2) {
            previewMarker = L.marker([bar.location.lat, bar.location.lng], {
              icon: previewIcon,
            }).addTo(map);

            previewLine = L.polyline(leafletCoords, {
              color: "#757575",
              weight: 3,
              opacity: 0.8,
              dashArray: "8, 6",
            }).addTo(map);

            // Compute bounds just from the previous and previewed bar
            const bounds = L.latLngBounds(
              [prevLocation.lat, prevLocation.lng],
              [bar.location.lat, bar.location.lng]
            );

            // Add some relative padding and limit zoom-in level
            map.fitBounds(bounds, {
              padding: [100, 100], // padding in pixels
              maxZoom: 14, // prevent over-zooming
            });

            setButtonsToPreviewState(true);
          } else {
            showMessage(
              `Could not determine direction for '${query}'. Try another guess.`,
              "error"
            );
          }
        } catch (error) {
          showMessage(error.message, "error");
        } finally {
          previewBtn.disabled = false;
          previewBtn.textContent = "Preview";
        }
      }

      function clearPreview() {
        if (previewLine) map.removeLayer(previewLine);
        if (previewMarker) map.removeLayer(previewMarker);
        previewLine = null;
        previewMarker = null;
        previewedLocation = null;
        setButtonsToPreviewState(false);
        barInput.value = "";
        if (!gameState.gameWon) barInput.disabled = false;
      }

      function resetGame() {
        gameScreen.classList.add("hidden");
        initialSetupScreen.classList.remove("hidden");

        gameState.visitedBars = [];
        gameState.visitCount = 0;
        gameState.gameWon = false;

        if (map) {
          map.remove();
          map = null;
        }
        if (boundaryMap) {
          boundaryMap.remove();
          boundaryMap = null;
        }

        document.getElementById("message").className = "";
        document.getElementById("message").textContent = "";
        barInput.value = "";

        //selectedSize = "M";
        //selectedMode = "custom";
        document
          .querySelectorAll(".size-btn")
          .forEach((b) => b.classList.remove("selected"));
        document
          .querySelector('.size-btn[data-size="M"]')
          .classList.add("selected");

        setButtonsToPreviewState(false);
        barInput.disabled = false;

        // Reset seed
        gameState.SEED = null;
        //document.getElementById("seedInput").value = "";
      }

      // --- BOUNDARY SETUP LOGIC ---
      function initBoundaryMap() {
        if (boundaryMap) {
          boundaryMap.remove();
          boundaryMap = null;
        }
        boundaryMap = L.map("boundaryMap").setView(
          [centerLocation.lat, centerLocation.lng],
          13
        );
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          attribution: "¬© OpenStreetMap contributors",
        }).addTo(boundaryMap);

        updateBoundaryRectangle();
      }

      function updateBoundaryRectangle() {
        const bounds = [
          [gameState.GAME_BOUNDS.south, gameState.GAME_BOUNDS.west],
          [gameState.GAME_BOUNDS.north, gameState.GAME_BOUNDS.east],
        ];

        if (boundaryRectangle) {
          boundaryRectangle.remove();
        }
        boundaryRectangle = L.rectangle(bounds, {
          color: "#667eea",
          weight: 3,
        }).addTo(boundaryMap);

        boundaryMap.fitBounds(bounds, { padding: [50, 50], maxZoom: 15 });
        updateBoundaryValues();
      }

      function updateBoundaryValues() {
        document.getElementById("northValue").textContent =
          gameState.GAME_BOUNDS.north.toFixed(4);
        document.getElementById("southValue").textContent =
          gameState.GAME_BOUNDS.south.toFixed(4);
        document.getElementById("eastValue").textContent =
          gameState.GAME_BOUNDS.east.toFixed(4);
        document.getElementById("westValue").textContent =
          gameState.GAME_BOUNDS.west.toFixed(4);
      }

      function adjustBoundary(direction, amount) {
        gameState.GAME_BOUNDS[direction] += amount;

        if (
          gameState.GAME_BOUNDS.north <=
          gameState.GAME_BOUNDS.south + 0.0001
        ) {
          gameState.GAME_BOUNDS[direction] -= amount;
          return;
        }
        if (gameState.GAME_BOUNDS.east <= gameState.GAME_BOUNDS.west + 0.0001) {
          gameState.GAME_BOUNDS[direction] -= amount;
          return;
        }

        updateBoundaryRectangle();
      }

      function calculateBoundsFromCenter(center, size) {
        if (gameState.selectedMode == "region") {
          return gameState.GAME_BOUNDS_Regions[size];
        } else {
          offset = SIZE_PRESETS[size] / 2;
          delta_lat = (offset / 6371) * (180 / Math.PI);
          delta_lon =
            ((offset / 6371) * (180 / Math.PI)) /
            Math.cos((center.lat * Math.PI) / 180);
          return {
            north: center.lat + delta_lat,
            south: center.lat - delta_lat,
            east: center.lng + delta_lon,
            west: center.lng - delta_lon,
          };
        }
      }

      // ENOCDER:
      function encodeState(state) {
        const json = JSON.stringify(state);
        const encoded = btoa(json);
        return encoded;
      }

      function decodeState(encodedString) {
        const json = atob(encodedString);
        const state = JSON.parse(json);
        return state;
      }

      // --- EVENT LISTENERS ---
      // Tab functionality (update your existing tab code)
      document.querySelectorAll(".tab-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          const tabName = btn.dataset.tab;
          gameState.selectedMode = tabName; // Set to 'custom' or 'region'

          // Update tab buttons
          document.querySelectorAll(".tab-btn").forEach((b) => {
            b.classList.remove("active");
          });
          btn.classList.add("active");

          // Update tab content
          document.querySelectorAll(".tab-content").forEach((content) => {
            content.classList.remove("active");
          });
          document
            .querySelector(`[data-tab-content="${tabName}"]`)
            .classList.add("active");
        });
      });

      // Custom size button functionality (update your existing code)
      document.querySelectorAll(".size-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          // Deselect all size and region buttons
          document
            .querySelectorAll(".size-btn")
            .forEach((b) => b.classList.remove("selected"));
          document
            .querySelectorAll(".region-btn")
            .forEach((b) => b.classList.remove("selected"));

          btn.classList.add("selected");
          gameState.selectedSize = btn.dataset.size; // Store the size
        });
      });

      // Region button functionality (update your existing code)
      document.querySelectorAll(".region-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          // Deselect all size and region buttons
          document
            .querySelectorAll(".size-btn")
            .forEach((b) => b.classList.remove("selected"));
          document
            .querySelectorAll(".region-btn")
            .forEach((b) => b.classList.remove("selected"));

          btn.classList.add("selected");
          gameState.selectedSize = btn.dataset.size; // Store the country/region
        });
      });

      continueBtn.addEventListener("click", async () => {
        const initialSetupError = document.getElementById("initialSetupError");
        initialSetupError.textContent = "";
        continueBtn.disabled = true;
        continueBtn.textContent = "Loading...";

        try {
          const startLocName = document
            .getElementById("startLocationInput")
            .value.trim();
          if (!startLocName)
            throw new Error("Please enter a starting location.");
          // Get seed from input or generate random one
          //const seedInput = document.getElementById("seedInput").value.trim();
          const seedInput = null;
          gameState.SEED =
            seedInput || Math.random().toString(36).substring(2, 10);

          //GAME_BOUNDS = calculateBoundsFromCenter(centerLocation, gameState.selectedSize);
          const bar = await geocodeLocation(startLocName);
          const startLocCoords = bar.location;
          gameState.startingPoint = { name: startLocName, ...startLocCoords };
          centerLocation = startLocCoords;

          gameState.GAME_BOUNDS = calculateBoundsFromCenter(
            centerLocation,
            gameState.selectedSize
          );

          initialSetupScreen.classList.add("hidden");
          boundarySetupScreen.classList.remove("hidden");

          setTimeout(initBoundaryMap, 10);
        } catch (error) {
          initialSetupError.textContent = `Error: ${error.message}`;
        } finally {
          continueBtn.disabled = false;
          continueBtn.textContent = "Continue to Map";
        }
      });

      backBtn.addEventListener("click", () => {
        boundarySetupScreen.classList.add("hidden");
        initialSetupScreen.classList.remove("hidden");
      });

      // Map Size Adjustment Buttons
      document.querySelectorAll(".adjust-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          const direction = btn.dataset.direction;
          const sign = btn.textContent.trim() === "+" ? 1 : -1;
          const step = STEP_SIZES[gameState.selectedSize]; // use the correct step for map size
          const amount = sign * step;
          adjustBoundary(direction, amount);
        });
      });

      const seedInfoBtn = document.getElementById("seedInfoBtn");

      seedInfoBtn.addEventListener("click", () => {
        const encodedState = encodeState(gameState);
        console.log("Encoded Game State:", encodedState);

        openSeedPopup(encodedState);
      });

      // Start Game Button
      startGameBtn.addEventListener("click", async () => {
        const boundaryError = document.getElementById("boundaryError");
        boundaryError.textContent = "";
        startGameBtn.disabled = true;
        startGameBtn.textContent = "Loading...";

        try {
          if (
            gameState.GAME_BOUNDS.north <= gameState.GAME_BOUNDS.south ||
            gameState.GAME_BOUNDS.east <= gameState.GAME_BOUNDS.west
          ) {
            throw new Error("Invalid boundaries.");
          }

          // TODO
          boundarySetupScreen.classList.add("hidden");
          gameScreen.classList.remove("hidden");

          setTimeout(initGame, 10);
        } catch (error) {
          boundaryError.textContent = `Error: ${error.message}`;
          startGameBtn.disabled = false;
          startGameBtn.textContent = "Start Game";
        } finally {
          setTimeout(() => {
            startGameBtn.disabled = false;
            startGameBtn.textContent = "Start Game";
          }, 1000);
        }
      });

      previewBtn.addEventListener("click", previewBar);
      confirmBtn.addEventListener("click", confirmBar);
      cancelBtn.addEventListener("click", clearPreview);
      resetBtn.addEventListener("click", resetGame);
      barInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter" && !previewBtn.classList.contains("hidden")) {
          previewBtn.click();
        }
      });
      restaurantCheckbox.addEventListener("change", (e) => {
        gameState.restaurantsConsidered = e.target.checked;
      });

      // Accordion functionality
      document.querySelectorAll(".section-header").forEach((header) => {
        header.addEventListener("click", () => {
          const section = header.parentElement;
          const wasActive = section.classList.contains("active");

          // Close all sections
          document.querySelectorAll(".setup-section").forEach((s) => {
            s.classList.remove("active");
          });

          // Open clicked section if it wasn't already active
          if (!wasActive) {
            section.classList.add("active");
          }
        });
      });

      // Tab functionality
      document.querySelectorAll(".tab-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          const tabName = btn.dataset.tab;

          // Update tab buttons
          document.querySelectorAll(".tab-btn").forEach((b) => {
            b.classList.remove("active");
          });
          btn.classList.add("active");

          // Update tab content
          document.querySelectorAll(".tab-content").forEach((content) => {
            content.classList.remove("active");
          });
          document
            .querySelector(`[data-tab-content="${tabName}"]`)
            .classList.add("active");
        });
      });

      // Custom size button functionality
      document.querySelectorAll(".size-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          // Deselect all size and region buttons
          document
            .querySelectorAll(".size-btn")
            .forEach((b) => b.classList.remove("selected"));
          document
            .querySelectorAll(".region-btn")
            .forEach((b) => b.classList.remove("selected"));

          btn.classList.add("selected");
          gameState.selectedSize = btn.dataset.size;
        });
      });

      // Region button functionality
      document.querySelectorAll(".region-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          // Deselect all size and region buttons
          document
            .querySelectorAll(".size-btn")
            .forEach((b) => b.classList.remove("selected"));
          document
            .querySelectorAll(".region-btn")
            .forEach((b) => b.classList.remove("selected"));

          btn.classList.add("selected");
          gameState.selectedSize = btn.dataset.size;
        });
      });

      // Continue Button
      continueBtn.addEventListener("click", async () => {
        const initialSetupError = document.getElementById("initialSetupError");
        initialSetupError.textContent = "";
        continueBtn.disabled = true;
        continueBtn.textContent = "Loading...";

        try {
          const startLocName = document
            .getElementById("startLocationInput")
            .value.trim();
          if (!startLocName)
            throw new Error("Please enter a starting location.");
          // Get seed from input or generate random one
          //const seedInput = document.getElementById("seedInput").value.trim();
          const seedInput = null;
          gameState.SEED =
            seedInput || Math.random().toString(36).substring(2, 10);

          const bar = await geocodeLocation(startLocName);
          const startLocCoords = bar.location;
          gameState.startingPoint = { name: startLocName, ...startLocCoords };
          centerLocation = startLocCoords;

          gameState.GAME_BOUNDS = calculateBoundsFromCenter(
            centerLocation,
            gameState.selectedSize
          );

          // Skip for Region mode
          const gameCode = document
            .getElementById("gameCodeInput")
            .value.trim();
          console.log("GAMECODE: ", gameCode);

          if (gameCode != "") {
            // if a game code is provided, decode it
            try {
              const decodedState = decodeState(gameCode);
              console.log("Decoded State:", decodedState);
              // Overwrite gameState with decoded values
              gameState = { ...gameState, ...decodedState };

              // Update UI based on decoded state
              document.getElementById("startLocationInput").value =
                gameState.startingPoint.name;

              boundarySetupScreen.classList.add("hidden");
              gameScreen.classList.remove("hidden");
              await initGame();
              setTimeout(() => {
                startGameBtn.disabled = false;
                startGameBtn.textContent = "Start Game";
              }, 1000);

              let visitedBars = gameState.visitedBars;
              let VisitCount = gameState.visitCount;
              gameState.visitedBars = [];
              gameState.visitCount = 0;
              for (const bar of visitedBars) {
                previewedLocation = {
                  name: bar.name,
                  location: {
                    lat: bar.lat,
                    lng: bar.lng,
                  },
                };
                await confirmBar();
              }

            } catch (e) {
              throw new Error("Invalid game code.");
            }
          } else {
            // otherwise, proceed as normal
            if (gameState.selectedMode === "custom") {
              initialSetupScreen.classList.add("hidden");
              boundarySetupScreen.classList.remove("hidden");
            } else {
              boundarySetupScreen.classList.add("hidden");
              gameScreen.classList.remove("hidden");
              setTimeout(initGame, 10);
              setTimeout(() => {
                startGameBtn.disabled = false;
                startGameBtn.textContent = "Start Game";
              }, 1000);
            }
          }

          setTimeout(initBoundaryMap, 10);
        } catch (error) {
          initialSetupError.textContent = `Error: ${error.message}`;
        } finally {
          continueBtn.disabled = false;
          continueBtn.textContent = "Continue to Map";
        }
      });

      // Add event listener for the dropdown
      document
        .getElementById("minimumOpenFor")
        .addEventListener("change", function (e) {
          const value = e.target.value;

          if (value === "none") {
            gameState.minimumOpenFor = null;
          } else if (value === "now") {
            gameState.minimumOpenFor = "now";
          } else {
            gameState.minimumOpenFor = parseInt(value, 10); // Convert to number (1, 2, 3, etc.)
          }

          console.log("minimumOpenFor set to:", gameState.minimumOpenFor);
        });

      // Pop Up
      document.addEventListener("DOMContentLoaded", () => {
        document
          .getElementById("popupClose")
          .addEventListener("click", closeSeedPopup);

        // Attach copy button listeners
        document.querySelectorAll(".copyBtn").forEach((btn) => {
          btn.addEventListener("click", () => {
            const id = btn.getAttribute("data-copy-target");
            const txt = document.getElementById(id).textContent;

            navigator.clipboard.writeText(txt).then(() => {
              const original = btn.textContent;
              btn.textContent = "Copied!";
              setTimeout(() => (btn.textContent = original), 1300);
            });
          });
        });
      });
    </script>
  </body>
</html>
