<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bar Hunt</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css"
    />
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div id="initialSetupScreen">
      <div class="initial-setup-card">
        <h1>BAR HUNT</h1>
        <div class="setup-group">
          <label for="startLocationInput">Starting Location</label>
          <input
            type="text"
            id="startLocationInput"
            value="Paradeplatz, Zurich"
            placeholder="Enter a location..."
          />
        </div>
        <div class="setup-group">
          <label>Game Boundary Size</label>
          <div class="size-options">
            <button class="size-btn" data-size="S">S</button>
            <button class="size-btn" data-size="M">M</button>
            <button class="size-btn" data-size="L">L</button>
            <button class="size-btn" data-size="XL">XL</button>
            <button class="size-btn" data-size="XXL">XXL</button>
            <button class="size-btn" data-size="XXXL">XXXL</button>
            <button class="size-btn" data-size="Switzerland">
              Switzerland
            </button>
            <button class="size-btn" data-size="Europe">Europe</button>
          </div>
        </div>
        <div class="setup-group">
          <label for="seedInput">Game Seed (optional)</label>
          <input
            type="text"
            id="seedInput"
            placeholder="Leave empty for random seed"
          />
        </div>
        <div id="initialSetupError"></div>
        <button id="continueBtn">Continue to Map</button>
      </div>
    </div>

    <div id="boundarySetupScreen" class="hidden">
      <div class="boundary-controls">
        <button id="backBtn">‚Üê Back</button>
        <h2>Adjust Game Area</h2>
        <p>Fine-tune the boundaries of the game area.</p>
        <div class="boundary-adjust">
          <div class="boundary-row">
            <label>North</label>
            <button
              class="adjust-btn"
              data-direction="north"
              data-amount="-0.001"
            >
              ‚àí
            </button>
            <span class="boundary-value" id="northValue">47.390</span>
            <button
              class="adjust-btn"
              data-direction="north"
              data-amount="0.001"
            >
              +
            </button>
          </div>
          <div class="boundary-row">
            <label>South</label>
            <button
              class="adjust-btn"
              data-direction="south"
              data-amount="0.001"
            >
              ‚àí
            </button>
            <span class="boundary-value" id="southValue">47.365</span>
            <button
              class="adjust-btn"
              data-direction="south"
              data-amount="-0.001"
            >
              +
            </button>
          </div>
          <div class="boundary-row">
            <label>East</label>
            <button
              class="adjust-btn"
              data-direction="east"
              data-amount="-0.001"
            >
              ‚àí
            </button>
            <span class="boundary-value" id="eastValue">8.560</span>
            <button
              class="adjust-btn"
              data-direction="east"
              data-amount="0.001"
            >
              +
            </button>
          </div>
          <div class="boundary-row">
            <label>West</label>
            <button
              class="adjust-btn"
              data-direction="west"
              data-amount="0.001"
            >
              ‚àí
            </button>
            <span class="boundary-value" id="westValue">8.520</span>
            <button
              class="adjust-btn"
              data-direction="west"
              data-amount="-0.001"
            >
              +
            </button>
          </div>
        </div>
        <div id="boundaryError"></div>
        <button id="startGameBtn">Start Game</button>
      </div>
      <div id="boundaryMap"></div>
    </div>

    <div id="gameScreen" class="hidden">
      <div class="header">
        <button id="resetBtn" title="New Game">
          <svg viewBox="0 0 24 24">
            <path
              d="M17.65,6.35C16.2,4.9,14.21,4,12,4A8,8,0,0,0,4,12A8,8,0,0,0,12,20C15.73,20,18.84,17.45,19.73,14H17.65C16.83,16.33,14.61,18,12,18A6,6,0,0,1,6,12A6,6,0,0,1,12,6C13.55,6,14.93,6.6,15.96,7.65L13,10.61H20V3.61L17.65,6.35Z"
            ></path>
          </svg>
        </button>
        <button id="seedInfoBtn" title="Show Seed">?</button>
        <h1>üç∫ Find the Secret Bar</h1>
        <div class="game-info">
          <span>üéØ Target: <strong id="targetBar">???</strong></span>
          <span>üèÉ Visits: <strong id="visitCount">0</strong></span>
          <span
            >üèÅ Starting Point:
            <strong id="startingBar">Paradeplatz</strong></span
          >
          <span>Bars Remaining: <strong id="remainingBars">???</strong></span>
        </div>
        <div class="search-container">
          <input
            type="text"
            id="barInput"
            class="search-input"
            placeholder="Enter a bar name..."
            autocomplete="off"
          />
          <button id="previewBtn" class="btn btn-primary">Preview</button>
          <button id="confirmBtn" class="btn btn-confirm hidden">
            Confirm Guess
          </button>
          <button id="cancelBtn" class="btn btn-cancel hidden">Cancel</button>
        </div>
        <div id="message"></div>
      </div>
      <div id="map"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/seedrandom@3.0.5/seedrandom.min.js"></script>
    <script type="module">
      // IMPORTS
      import {
        buildPolygon,
        getLineCoordsBetween,
        getIntersections,
        sphericalDistance,
        lonLatToCartesian,
      } from "./SphericalPolygon.js";
      import {
        createEliminationZone,
        isPointInPolygon,
      } from "./PlanarPolygon.js";
      import { drawRandomBarFromDensityGrid } from "./GlobalBarSelection.js";

      // Make the function global so other scripts can see it
      window.buildPolygon = buildPolygon;
      window.createEliminationZone = createEliminationZone;
      window.getLineCoordsBetween = getLineCoordsBetween;
      window.getIntersections = getIntersections;
      window.isPointInPolygon = isPointInPolygon;
      window.sphericalDistance = sphericalDistance;
      window.lonLatToCartesian = lonLatToCartesian;

      window.drawRandomBarFromDensityGrid = drawRandomBarFromDensityGrid;
    </script>
    <script>
      // --- DOM ELEMENTS ---
      const initialSetupScreen = document.getElementById("initialSetupScreen");
      const boundarySetupScreen = document.getElementById(
        "boundarySetupScreen"
      );
      const gameScreen = document.getElementById("gameScreen");
      const continueBtn = document.getElementById("continueBtn");
      const startGameBtn = document.getElementById("startGameBtn");
      const backBtn = document.getElementById("backBtn");
      const barInput = document.getElementById("barInput");
      const previewBtn = document.getElementById("previewBtn");
      const confirmBtn = document.getElementById("confirmBtn");
      const cancelBtn = document.getElementById("cancelBtn");
      const resetBtn = document.getElementById("resetBtn");

      // --- SIZE PRESETS ---
      const SIZE_PRESETS = {
        S: 1, //km
        M: 2,
        L: 10,
        XL: 25,
        XXL: 100,
        XXXL: 500,
        Switzerland: null,
        Europe: null,
      };
      let selectedSize = "M";
      let gameMode = "custom"; // 'custom' or 'region'

      // --- GAME STATE & VARS ---
      let GAME_BOUNDS = { south: 47.365, north: 47.39, west: 8.52, east: 8.56 };
      let centerLocation = { lat: 47.3769, lng: 8.5417 };

      let GAME_BOUNDS_Switzerland = {
        south: 45.817,
        north: 47.808,
        west: 5.955,
        east: 10.492,
      };
      let GAME_BOUNDS_Europe = {
        south: 34.5,
        north: 71.2,
        west: -25.0,
        east: 40.0,
      };

      let gameState = {
        targetBar: null,
        targetLocation: null,
        visitedBars: [],
        visitCount: 0,
        gameWon: false,
        startingPoint: { name: "Paradeplatz", lat: 47.3697, lng: 8.5392 },
      };
      let allBarsInArea = []; // FIX 1: To store bars and prevent re-fetching
      let previewedLocation = null;
      let map = null;
      let boundaryMap = null;
      let boundaryRectangle = null;
      let gameArea = null;
      let markers = [];
      let pathLine = null;
      let eliminationZones = [];
      let eliminationPolygons = []; // INSIDE
      let remainingBarsEveryTurn = []; // INSIDE
      let previewLine = null;
      let previewMarker = null;
      let SEED = null;

      // --- ICONS ---
      const visitedIcon = (number, isWarmer) =>
        L.divIcon({
          html: `<div style="background: ${
            isWarmer ? "#FF6347" : "#4169E1"
          }; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: 600; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">${number}</div>`,
          className: "",
          iconSize: [32, 32],
          iconAnchor: [16, 16],
          popupAnchor: [0, -16],
        });
      const winIcon = L.divIcon({
        html: '<div style="background: #4CAF50; color: white; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px; border: 3px solid white; box-shadow: 0 2px 12px rgba(0,0,0,0.4); animation: pulse 1s infinite;">üéâ</div><style>@keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); }}</style>',
        className: "",
        iconSize: [40, 40],
        iconAnchor: [20, 20],
        popupAnchor: [0, -20],
      });
      const startIcon = L.divIcon({
        html: '<div style="background: #FFA500; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 18px; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">üèÅ</div>',
        className: "",
        iconSize: [32, 32],
        iconAnchor: [16, 16],
        popupAnchor: [0, -16],
      });
      const previewIcon = L.divIcon({
        html: '<div style="background: #f97316; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 18px; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">?</div>',
        className: "",
        iconSize: [32, 32],
        iconAnchor: [16, 16],
      });

      // --- GAME LOGIC ---
      async function geocodeLocation(query, bounds = null) {
        let url;
        if (bounds) {
          // Compute center and bias search around visible map area
          const centerLat = (bounds.north + bounds.south) / 2;
          const centerLng = (bounds.east + bounds.west) / 2;

          // Photon supports lat/lon biasing + bounding box via "bbox"
          url = `https://photon.komoot.io/api/?q=${encodeURIComponent(
            query
          )}&lat=${centerLat}&lon=${centerLng}&bbox=${bounds.west},${
            bounds.south
          },${bounds.east},${bounds.north}&limit=1`;
        } else {
          // fallback global search
          const centerLat = (GAME_BOUNDS.north + GAME_BOUNDS.south) / 2;
          const centerLng = (GAME_BOUNDS.east + GAME_BOUNDS.west) / 2;
          url = `https://photon.komoot.io/api/?q=${encodeURIComponent(
            query
          )}&lat=${centerLat}&lon=${centerLng}&limit=1`;
        }

        const response = await fetch(url);
        if (!response.ok) throw new Error("Network error");
        const data = await response.json();
        if (!data.features || data.features.length === 0) return null;

        const { coordinates } = data.features[0].geometry;
        return { lat: coordinates[1], lng: coordinates[0] };
      }

      async function fetchBarsInBounds() {
        const overpassUrl = "https://overpass-api.de/api/interpreter";
        const query = `
                [out:json][timeout:25];
                (
                  node["amenity"="bar"](${GAME_BOUNDS.south},${GAME_BOUNDS.west},${GAME_BOUNDS.north},${GAME_BOUNDS.east});
                  node["amenity"="pub"](${GAME_BOUNDS.south},${GAME_BOUNDS.west},${GAME_BOUNDS.north},${GAME_BOUNDS.east});
                );
                out body;
            `;

        const response = await fetch(overpassUrl, {
          method: "POST",
          body: query,
        });

        if (!response.ok)
          throw new Error("Failed to fetch bars from OpenStreetMap");
        const data = await response.json();

        const bars = data.elements
          .filter((el) => el.tags && el.tags.name)
          .map((el) => ({
            name: el.tags.name,
            lat: el.lat,
            lng: el.lon,
            inside: true,
          }));

        if (bars.length < 2) {
          throw new Error(
            "Fewer than 2 bars found in the area. Please select a larger or different location."
          );
        }

        return bars;
      }

      function showMessage(text, type) {
        const msgDiv = document.getElementById("message");
        msgDiv.textContent = text;
        msgDiv.className = `message ${type}`;
        if (type !== "win") {
          setTimeout(() => {
            msgDiv.textContent = "";
            msgDiv.className = "";
          }, 3000);
        }
      }
      function updatePath() {
        if (pathLine) map.removeLayer(pathLine);
        if (gameState.visitedBars.length > 0) {
          const points = [
            [gameState.startingPoint.lat, gameState.startingPoint.lng],
            ...gameState.visitedBars.map((bar) => [bar.lat, bar.lng]),
          ];
          pathLine = L.polyline(points, {
            color: "#667eea",
            weight: 3,
            opacity: 0.7,
            dashArray: "10, 10",
          }).addTo(map);
        }
      }

      async function initGame() {
        if (map) {
          map.remove();
          map = null;
        }
        map = L.map("map").setView(
          [centerLocation.lat, centerLocation.lng],
          14
        );
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          attribution: "¬© OpenStreetMap contributors",
          maxZoom: 19,
        }).addTo(map);

        markers.forEach((marker) => marker.remove());
        markers = [];
        if (pathLine) pathLine.remove();
        pathLine = null;
        eliminationZones.forEach((zone) => zone.remove());
        eliminationZones = [];
        clearPreview();

        // FIX 1: Fetch bars once and store them
        showMessage("Searching for bars in the area...", "success");
        try {
          if (gameMode === "region") {
            allBarsInArea = await drawRandomBarFromDensityGrid(GAME_BOUNDS);
          } else {
            allBarsInArea = await fetchBarsInBounds();
          }
        } catch (error) {
          showMessage(error.message, "error");
          setTimeout(resetGame, 3000);
          return;
        }
        const bars = allBarsInArea; // Use the global list for setup

        // INSIDE: Display all bars on map (for testing)
        if (SEED == "Hacker") {
          bars.forEach((bar) => {
            const icon = L.divIcon({
              html: '<div style="background:red;width:12px;height:12px;border-radius:50%;border:2px solid white;"></div>',
              className: "",
            });

            const marker = L.marker([bar.lat, bar.lng], { icon }).addTo(map);
            marker.bindPopup(
              `<div class="bar-popup"><h3>${bar.name}</h3></div>`
            );
            marker.on("click", () => {
              marker.openPopup();
              const input = document.getElementById("barInput");
              if (input) input.value = bar.name;
            });

            markers.push(marker);
          });
        }

        if (!SEED) {
          SEED = Math.random().toString(36).substring(2, 10);
        }

        const rng = new Math.seedrandom(SEED);
        const targetBar = bars[Math.floor(rng() * bars.length)];

        console.log("Target Bar: ", targetBar.name);

        gameArea = L.rectangle(
          [
            [GAME_BOUNDS.south, GAME_BOUNDS.west],
            [GAME_BOUNDS.north, GAME_BOUNDS.east],
          ],
          { color: "#667eea", weight: 2, fillOpacity: 0.1, dashArray: "5, 5" }
        ).addTo(map);
        gameArea.bindPopup("Game Area - Find bars within this zone!");

        gameState.targetBar = targetBar.name;
        gameState.targetLocation = { lat: targetBar.lat, lng: targetBar.lng };
        gameState.visitedBars = [];
        gameState.visitCount = 0;
        gameState.gameWon = false;

        const startMarker = L.marker(
          [gameState.startingPoint.lat, gameState.startingPoint.lng],
          { icon: startIcon }
        ).addTo(map);
        startMarker.bindPopup(
          `<div class="bar-popup"><h3>üèÅ Starting Point</h3><p>${gameState.startingPoint.name}</p></div>`
        );
        markers.push(startMarker);

        // INSIDE
        if (SEED == "Hacker") {
          const remainingBars = allBarsInArea.filter(
            (bar) => bar.inside
          ).length;
          remainingBarsEveryTurn.push(remainingBars);
          document.getElementById(
            "remainingBars"
          ).textContent = `${remainingBars}/${bars.length}`;
        }

        document.getElementById("targetBar").textContent = "???";
        document.getElementById("visitCount").textContent = "0";
        document.getElementById("startingBar").textContent =
          gameState.startingPoint.name;
        barInput.disabled = false;
        previewBtn.disabled = false;
        showMessage(
          `Game started! ${bars.length} bars found in area. Find the hidden bar.`,
          "success"
        );
        map.fitBounds(gameArea.getBounds(), { padding: [10, 10] });
      }

      async function tryBar() {
        if (gameState.gameWon || !previewedLocation) return;

        const userEnteredName = barInput.value.trim();
        const foundBarName = await findClosestBarName(previewedLocation);
        const location = previewedLocation;
        clearPreview();

        const prevLocation =
          gameState.visitedBars.length > 0
            ? gameState.visitedBars[gameState.visitedBars.length - 1]
            : gameState.startingPoint;
        const p1_xy = lonLatToCartesian(prevLocation.lng, prevLocation.lat);
        const p2_xy = lonLatToCartesian(location.lng, location.lat);
        const target_xy = lonLatToCartesian(
          gameState.targetLocation.lng,
          gameState.targetLocation.lat
        );
        const currentDist = sphericalDistance(p2_xy, target_xy);
        const prevDist = sphericalDistance(p1_xy, target_xy);
        const isWarmer = currentDist < prevDist;

        gameState.visitCount++;
        //gameState.visitedBars.push({ name: foundBarName, ...location });
        gameState.visitedBars.push({ name: userEnteredName, ...location });

        const isWin =
          foundBarName.toLowerCase() === gameState.targetBar.toLowerCase();
        const icon = isWin
          ? winIcon
          : visitedIcon(gameState.visitCount, isWarmer);

        const marker = L.marker([location.lat, location.lng], { icon })
          .addTo(map)
          .bindPopup(
            `<div class="bar-popup"><h3>${
              isWin ? "üéâ " : isWarmer ? "üî• " : "‚ùÑÔ∏è "
            }${userEnteredName}</h3><p><span class="visit-number">${
              gameState.visitCount
            }</span> Visit #${gameState.visitCount}</p>${
              !isWin
                ? `<p style="font-weight: 600; color: ${
                    isWarmer ? "#FF6347" : "#4169E1"
                  }">${isWarmer ? "üî• Warmer!" : "‚ùÑÔ∏è Colder!"}</p>`
                : ""
            }${
              isWin
                ? '<p style="color: #4CAF50; font-weight: 600;">YOU FOUND IT!</p>'
                : ""
            }</div>`
          )
          .openPopup();
        markers.push(marker);

        const pt1LonLat = [prevLocation.lng, prevLocation.lat];
        const pt2LonLat = [location.lng, location.lat];

        let eliminationZone;

        //if (selectedSize == 'S' || selectedSize == 'M' || selectedSize == 'L') {
        if (selectedSize == null) {
          eliminationZone = window.createEliminationZone(
            prevLocation,
            location,
            GAME_BOUNDS,
            isWarmer
          );
        } else {
          eliminationZone = window.buildPolygon(
            GAME_BOUNDS,
            [pt1LonLat, pt2LonLat],
            isWarmer
          );
        }

        const leafletCoords = eliminationZone.map((c) => [c[1], c[0]]);
        const zone = L.polygon(leafletCoords, {
          color: "#dc2626",
          weight: 1,
          fillColor: "#ef4444",
          fillOpacity: 0.2,
        }).addTo(map);
        eliminationZones.push(zone);
        // INSIDE: Update bars inside elimination zones
        if (SEED == "Hacker") {
          allBarsInArea.forEach((bar) => {
            if (bar.inside) {
              const point = { lat: bar.lat, lng: bar.lng };
              if (window.isPointInPolygon(point, eliminationZone)) {
                bar.inside = false;
              }
            }
          });
        }

        updatePath();
        map.flyTo([location.lat, location.lng], Math.max(map.getZoom(), 16), {
          duration: 1,
        });
        document.getElementById("visitCount").textContent =
          gameState.visitCount;

        if (isWin) {
          gameState.gameWon = true;
          document.getElementById("targetBar").textContent =
            gameState.targetBar;
          showMessage(
            `üéâ Congratulations! You found ${gameState.targetBar} in ${gameState.visitCount} tries!`,
            "win"
          );
          barInput.disabled = true;
          previewBtn.disabled = true;
        } else {
          showMessage(
            isWarmer ? "üî• Getting warmer!" : "‚ùÑÔ∏è Getting colder!",
            isWarmer ? "warmer" : "colder"
          );
          // INSIDE
          if (SEED == "Hacker") {
            const remainingBars = allBarsInArea.filter(
              (bar) => bar.inside
            ).length;
            remainingBarsEveryTurn.push(remainingBars);
            document.getElementById(
              "remainingBars"
            ).textContent = `${remainingBars}/${allBarsInArea.length}`;
          }
        }
      }

      // FIX 1: Modified to use the global allBarsInArea list
      async function findClosestBarName(location) {
        const bars = allBarsInArea;
        if (!bars || bars.length === 0) return barInput.value.trim();

        let closestBar = null;
        let minDistance = Infinity;

        for (const bar of bars) {
          const p1_xy = lonLatToCartesian(location.lng, location.lat);
          const p2_xy = lonLatToCartesian(bar.lng, bar.lat);
          const dist = sphericalDistance(p1_xy, p2_xy);
          if (dist < minDistance) {
            minDistance = dist;
            closestBar = bar;
          }
        }
        return closestBar ? closestBar.name : barInput.value.trim();
      }

      function setButtonsToPreviewState(isPreviewing) {
        previewBtn.classList.toggle("hidden", isPreviewing);
        confirmBtn.classList.toggle("hidden", !isPreviewing);
        cancelBtn.classList.toggle("hidden", !isPreviewing);
        barInput.disabled = isPreviewing;
      }

      async function previewBar() {
        const query = barInput.value.trim();
        if (!query) {
          showMessage("Please enter a bar name to preview.", "error");
          return;
        }

        previewBtn.disabled = true;
        previewBtn.textContent = "...";

        try {
          const mapWindow = map.getBounds();
          const currentBounds = {
            north: mapWindow.getNorth(),
            south: mapWindow.getSouth(),
            east: mapWindow.getEast(),
            west: mapWindow.getWest(),
          };

          // try searching within current map window first
          let location = await geocodeLocation(query, currentBounds);
          if (!location) {
            location = await geocodeLocation(query, null);
         }
          //const location = await geocodeLocation(query);
          if (
            location.lat < GAME_BOUNDS.south ||
            location.lat > GAME_BOUNDS.north ||
            location.lng < GAME_BOUNDS.west ||
            location.lng > GAME_BOUNDS.east
          ) {
            showMessage(`'${query}' is outside the game area.`, "error");
            return;
          }
          previewedLocation = location;

          const prevLocation =
            gameState.visitedBars.length > 0
              ? gameState.visitedBars[gameState.visitedBars.length - 1]
              : gameState.startingPoint;

          const p1_lonlat = [prevLocation.lng, prevLocation.lat];
          const p2_lonlat = [location.lng, location.lat];
          const p1_xy = window.lonLatToCartesian(
            prevLocation.lng,
            prevLocation.lat
          );
          const p2_xy = window.lonLatToCartesian(location.lng, location.lat);
          const boundaryIntersections = window.getIntersections(
            p1_lonlat,
            p2_lonlat,
            GAME_BOUNDS
          );
          const linePoints = window.getLineCoordsBetween(
            boundaryIntersections[0],
            boundaryIntersections[1]
          );
          const leafletCoords = linePoints.map((c) => [c[1], c[0]]);
          console.log("Line Points:", linePoints);

          if (linePoints.length >= 2) {
            previewMarker = L.marker([location.lat, location.lng], {
              icon: previewIcon,
            }).addTo(map);

            previewLine = L.polyline(leafletCoords, {
              color: "#f97316",
              weight: 4,
              opacity: 0.8,
              dashArray: "8, 8",
            }).addTo(map);

            // Compute bounds just from the previous and previewed bar
            const bounds = L.latLngBounds(
                [prevLocation.lat, prevLocation.lng],
                [location.lat, location.lng]
            );

            // Add some relative padding and limit zoom-in level
            map.fitBounds(bounds, {
                padding: [100, 100],  // padding in pixels
                maxZoom: 16,          // prevent over-zooming
            });

            setButtonsToPreviewState(true);
          } else {
            showMessage(
              `Could not determine direction for '${query}'. Try another guess.`,
              "error"
            );
          }
        } catch (error) {
          showMessage(error.message, "error");
        } finally {
          previewBtn.disabled = false;
          previewBtn.textContent = "Preview";
        }
      }

      function clearPreview() {
        if (previewLine) map.removeLayer(previewLine);
        if (previewMarker) map.removeLayer(previewMarker);
        previewLine = null;
        previewMarker = null;
        previewedLocation = null;
        setButtonsToPreviewState(false);
        barInput.value = "";
        if (!gameState.gameWon) barInput.disabled = false;
      }

      function resetGame() {
        gameScreen.classList.add("hidden");
        initialSetupScreen.classList.remove("hidden");

        if (map) {
          map.remove();
          map = null;
        }
        if (boundaryMap) {
          boundaryMap.remove();
          boundaryMap = null;
        }

        document.getElementById("message").className = "";
        document.getElementById("message").textContent = "";
        barInput.value = "";

        selectedSize = "M";
        document
          .querySelectorAll(".size-btn")
          .forEach((b) => b.classList.remove("selected"));
        document
          .querySelector('.size-btn[data-size="M"]')
          .classList.add("selected");

        setButtonsToPreviewState(false);
        barInput.disabled = false;

        // Reset seed
        SEED = null;
        document.getElementById("seedInput").value = "";
      }

      // --- BOUNDARY SETUP LOGIC ---
      function initBoundaryMap() {
        if (boundaryMap) {
          boundaryMap.remove();
          boundaryMap = null;
        }
        boundaryMap = L.map("boundaryMap").setView(
          [centerLocation.lat, centerLocation.lng],
          13
        );
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          attribution: "¬© OpenStreetMap contributors",
        }).addTo(boundaryMap);

        updateBoundaryRectangle();
      }

      function updateBoundaryRectangle() {
        const bounds = [
          [GAME_BOUNDS.south, GAME_BOUNDS.west],
          [GAME_BOUNDS.north, GAME_BOUNDS.east],
        ];

        if (boundaryRectangle) {
          boundaryRectangle.remove();
        }
        boundaryRectangle = L.rectangle(bounds, {
          color: "#667eea",
          weight: 3,
        }).addTo(boundaryMap);

        boundaryMap.fitBounds(bounds, { padding: [50, 50], maxZoom: 15 });
        updateBoundaryValues();
      }

      function updateBoundaryValues() {
        document.getElementById("northValue").textContent =
          GAME_BOUNDS.north.toFixed(4);
        document.getElementById("southValue").textContent =
          GAME_BOUNDS.south.toFixed(4);
        document.getElementById("eastValue").textContent =
          GAME_BOUNDS.east.toFixed(4);
        document.getElementById("westValue").textContent =
          GAME_BOUNDS.west.toFixed(4);
      }

      function adjustBoundary(direction, amount) {
        GAME_BOUNDS[direction] += amount;

        if (GAME_BOUNDS.north <= GAME_BOUNDS.south + 0.001) {
          GAME_BOUNDS[direction] -= amount;
          return;
        }
        if (GAME_BOUNDS.east <= GAME_BOUNDS.west + 0.001) {
          GAME_BOUNDS[direction] -= amount;
          return;
        }

        updateBoundaryRectangle();
      }

      function calculateBoundsFromCenter(center, size) {
        if (size === "Switzerland") {
          gameMode = "region";
          return GAME_BOUNDS_Switzerland;
        } else if (size === "Europe") {
          gameMode = "region";
          return GAME_BOUNDS_Europe;
        } else {
          offset = SIZE_PRESETS[size] / 2;
          delta_lat = (offset / 6371) * (180 / Math.PI);
          delta_lon =
            ((offset / 6371) * (180 / Math.PI)) /
            Math.cos((center.lat * Math.PI) / 180);
          return {
            north: center.lat + delta_lat,
            south: center.lat - delta_lat,
            east: center.lng + delta_lon,
            west: center.lng - delta_lon,
          };
        }
      }

      // --- EVENT LISTENERS ---
      document.querySelectorAll(".size-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          document
            .querySelectorAll(".size-btn")
            .forEach((b) => b.classList.remove("selected"));
          btn.classList.add("selected");
          selectedSize = btn.dataset.size;
        });
      });

      continueBtn.addEventListener("click", async () => {
        const initialSetupError = document.getElementById("initialSetupError");
        initialSetupError.textContent = "";
        continueBtn.disabled = true;
        continueBtn.textContent = "Loading...";

        try {
          const startLocName = document
            .getElementById("startLocationInput")
            .value.trim();
          if (!startLocName)
            throw new Error("Please enter a starting location.");
          // Get seed from input or generate random one
          const seedInput = document.getElementById("seedInput").value.trim();
          SEED = seedInput || Math.random().toString(36).substring(2, 10);

          GAME_BOUNDS = calculateBoundsFromCenter(centerLocation, selectedSize);
          const startLocCoords = await geocodeLocation(startLocName);
          gameState.startingPoint = { name: startLocName, ...startLocCoords };
          centerLocation = startLocCoords;

          GAME_BOUNDS = calculateBoundsFromCenter(centerLocation, selectedSize);

          initialSetupScreen.classList.add("hidden");
          boundarySetupScreen.classList.remove("hidden");

          setTimeout(initBoundaryMap, 10);
        } catch (error) {
          initialSetupError.textContent = `Error: ${error.message}`;
        } finally {
          continueBtn.disabled = false;
          continueBtn.textContent = "Continue to Map";
        }
      });

      backBtn.addEventListener("click", () => {
        boundarySetupScreen.classList.add("hidden");
        initialSetupScreen.classList.remove("hidden");
      });

      document.querySelectorAll(".adjust-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          const direction = btn.dataset.direction;
          const amount = parseFloat(btn.dataset.amount);
          adjustBoundary(direction, amount);
        });
      });

      const seedInfoBtn = document.getElementById("seedInfoBtn");

      seedInfoBtn.addEventListener("click", () => {
        const msgDiv = document.getElementById("message");
        msgDiv.innerHTML = `<strong>üé≤ Game Seed:</strong> ${SEED}<br><small>Share this seed with friends to play the same game!</small>`;
        msgDiv.className = "message success";

        // Copy to clipboard
        navigator.clipboard
          .writeText(SEED)
          .then(() => {
            msgDiv.innerHTML = `<strong>üé≤ Game Seed:</strong> ${SEED} <span style="color: #4CAF50;">‚úì Copied!</span><br><small>Share this seed with friends to play the same game!</small>`;
          })
          .catch(() => {
            // Clipboard failed, just show the seed
          });
      });

      startGameBtn.addEventListener("click", async () => {
        const boundaryError = document.getElementById("boundaryError");
        boundaryError.textContent = "";
        startGameBtn.disabled = true;
        startGameBtn.textContent = "Loading...";

        try {
          if (
            GAME_BOUNDS.north <= GAME_BOUNDS.south ||
            GAME_BOUNDS.east <= GAME_BOUNDS.west
          ) {
            throw new Error("Invalid boundaries.");
          }

          boundarySetupScreen.classList.add("hidden");
          gameScreen.classList.remove("hidden");

          setTimeout(initGame, 10);
        } catch (error) {
          boundaryError.textContent = `Error: ${error.message}`;
          startGameBtn.disabled = false;
          startGameBtn.textContent = "Start Game";
        } finally {
          setTimeout(() => {
            startGameBtn.disabled = false;
            startGameBtn.textContent = "Start Game";
          }, 1000);
        }
      });

      previewBtn.addEventListener("click", previewBar);
      confirmBtn.addEventListener("click", tryBar);
      cancelBtn.addEventListener("click", clearPreview);
      resetBtn.addEventListener("click", resetGame);
      barInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter" && !previewBtn.classList.contains("hidden")) {
          previewBtn.click();
        }
      });
    </script>
  </body>
</html>
